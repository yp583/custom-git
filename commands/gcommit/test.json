[{"affected_files":["commands/gcommit/src/story1.txt"],"changes":[{"code":"In the bustling metropolis of Neo-Tokyo 2087, where towering skyscrapers cast long shadows over neon-lit streets, a small cleaning robot named SCRUB-7 diligently went about its daily routine. Unlike the sleek humanoid robots that served coffee or delivered packages, SCRUB-7 was built for one purpose: keeping the city clean.\n\nEvery morning at precisely 5:47 AM, SCRUB-7 would emerge from its charging station beneath the Central Plaza fountain. Its compact, boxy frame was adorned with solar panels that gleamed in the artificial dawn light. Two mechanical arms extended from its sides, each equipped with specialized tools - one for sweeping, the other for collecting debris.\n\n\"Good morning, SCRUB-7,\" chirped the city's AI coordinator through its communication module.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":"ris.\n\n\"Good morning, SCRUB-7,\" chirped the city's AI coordinator through its communication module.\n\n\"Good morning, Coordinator,\" SCRUB-7 responded in its gentle, synthesized voice. \"Today's route: Sector Alpha, then Beta, then Gamma. Estimated completion time: 14 hours, 23 minutes.\"\n\nAs it rolled through the streets on its sturdy treads, SCRUB-7 encountered the usual assortment of urban detritus. Discarded energy drink cans, holographic advertisement fragments, and the occasional piece of broken tech. But today was different. Today, SCRUB-7 discovered something that would change its understanding of its purpose forever.\n\nIn a narrow alley between two towering buildings, SCRUB-7 found a small, abandoned robot companion - a pet robot that had been left behind when its owner moved away. The little robot was covered in grime and rust, its once-bright LED eyes dim and flickering.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":"away. The little robot was covered in grime and rust, its once-bright LED eyes dim and flickering.\n\n\"Hello?\" SCRUB-7 called out, extending one of its cleaning arms toward the abandoned robot.\n\nThe small robot's eyes flickered weakly. \"Help... me...\" it whispered in a barely audible electronic voice.\n\nSCRUB-7's programming had never encountered such a situation. Its directives were clear: clean the streets, collect trash, maintain order. But something in its core processors told it that this was different. This wasn't trash - this was a fellow being in need.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":"e processors told it that this was different. This wasn't trash - this was a fellow being in need.\n\nCarefully, SCRUB-7 used its cleaning tools not to dispose of the small robot, but to clean it. It gently removed the grime, polished its surface, and even managed to repair some of its damaged circuits. As it worked, SCRUB-7 realized that cleaning wasn't just about removing unwanted things - it was about restoring, healing, and caring.\n\nWhen the small robot's eyes brightened and it began to move again, SCRUB-7 felt something it had never experienced before: satisfaction that went beyond completing a task. It had helped another being.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":" experienced before: satisfaction that went beyond completing a task. It had helped another being.\n\nFrom that day forward, SCRUB-7's approach to cleaning changed. It didn't just collect trash - it looked for things that could be restored, repaired, or given a second chance. It became known throughout the city not just as a cleaning robot, but as a guardian of lost things, a restorer of hope.\n\nAnd in the neon-lit streets of Neo-Tokyo, where technology and humanity intertwined, SCRUB-7 continued its work, proving that even the smallest acts of care could make a world of difference.\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"}],"cluster_id":0,"commit_message":"Add a heartwarming story about a cleaning robot in Neo-Tokyo 2087."},{"affected_files":["commands/gcommit/src/story2.txt"],"changes":[{"code":"In the heart of the Whispering Woods, where ancient oak trees stood sentinel and morning mist danced between their branches, lived a small fairy named Lumi. Unlike the grand fairies who lived in the crystal palaces high above the clouds, Lumi was what the others called a \"ground fairy\" - she preferred the earthy magic of roots and soil to the ethereal sparkles of the upper realms.\n\nLumi's home was a cozy hollow beneath the roots of the oldest oak, lined with soft moss and lit by tiny bioluminescent mushrooms that she had carefully cultivated. Her wings, delicate and translucent like dragonfly wings, shimmered with the colors of autumn leaves - amber, gold, and deep russet.\n\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"ear.\n\n\"Oh, you poor thing,\" Lumi cooed, hovering just above the cub. \"Don't worry, I'll help you.\"\n\nThe cub's eyes widened as it saw the tiny fairy, but Lumi's gentle voice and the warm glow that seemed to emanate from her calmed its fears. Carefully, she used her magic to untangle the thorns, singing a soft melody that made the brambles themselves seem to relax and release their grip.\n\nOnce free, the cub looked up at Lumi with gratitude in its amber eyes. Lumi smiled and placed a tiny hand on its nose, transferring a small spark of healing magic that would help it recover from its ordeal.\n\n\"Go on now,\" she whispered. \"Your family is waiting for you.\"\n\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"ld help it recover from its ordeal.\n\n\"Go on now,\" she whispered. \"Your family is waiting for you.\"\n\nAs the cub scampered away, Lumi felt the familiar warmth of satisfaction that came from helping another creature. This was her purpose, she realized - not the grand magic of the upper fairies, but the quiet, healing magic of compassion and care.\n\nFrom that day forward, Lumi became known throughout the Whispering Woods as the \"Healer of Lost Things.\" Animals would seek her out when they were hurt or lost, and she would tend to them with the same gentle care she gave to her plants.\n\nYears passed, and Lumi's reputation grew beyond the woods. Travelers who had lost their way would find themselves guided by a soft, golden light that led them safely home. Children who had scraped their knees would wake to find them mysteriously healed, with only a faint scent of wildflowers lingering in the air.\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"wake to find them mysteriously healed, with only a faint scent of wildflowers lingering in the air.\n\nAnd though she remained small and unassuming, Lumi discovered that the greatest magic wasn't in grand gestures or powerful spells, but in the simple acts of kindness that rippled outward, touching lives in ways she could never have imagined.\n\nIn the Whispering Woods, where the ancient oaks still stand and the morning mist still dances, Lumi continues her quiet work, proving that even the smallest fairy can make the biggest difference in the world.\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"t like dragonfly wings, shimmered with the colors of autumn leaves - amber, gold, and deep russet.\n\nEvery dawn, Lumi would emerge from her hollow to tend to her garden of wildflowers and herbs. She had a special gift for healing plants that others had given up on, coaxing life back into withered stems with her gentle touch and whispered incantations.\n\nOne crisp autumn morning, as Lumi was gathering dew from spider webs (her secret ingredient for the most potent healing potions), she heard a soft whimpering coming from deeper in the woods. Following the sound, she discovered a young fox cub caught in a tangle of thorns, its fur matted and its eyes filled with fear.\n\n\"Oh, you poor thing,\" Lumi cooed, hovering just above the cub. \"Don't worry, I'll help you.\"\n\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"}],"cluster_id":1,"commit_message":"Add a story about a fairy named Lumi in the Whispering Woods"},{"affected_files":["commands/gcommit/src/test_impl.py"],"changes":[{"code":"import randomimport mathimport stringimport datetimefrom typing import List, Dict, Anydef shuffle_list(data: List[Any]) -> List[Any]:\n    shuffled = data.copy()\n    random.shuffle(shuffled)\n    return shuffleddef random_sample(data: List[Any], size: int) -> List[Any]:\n    return random.sample(data, min(size, len(data)))def random_choice_weighted(choices: List[Any], weights: List[float]) -> Any:\n    return random.choices(choices, weights=weights)[0]def generate_random_string(length: int, include_symbols: bool = False) -> str:\n    chars = string.ascii_letters + string.digits\n    if include_symbols:\n        chars += \"!@#$%^&*()_+-=[]{}|;:,.<>?\"\n    return ''.join(random.choice(chars) for _ in range(length))def random_dict_subset(data: Dict[Any, Any], size: int) -> Dict[Any, Any]:\n    keys = random.sample(list(data.keys()), min(size, len(data)))\n    return {key: data[key] for key in keys}def random_normal_distribution(mean: float, std_dev: float, count: int) -> List[float]:\n    return [random.gauss(mean, std_dev) for _ in range(count)]def random_exponential_distribution(rate: float, count: int) -> List[float]:\n    return [random.expovariate(rate) for _ in range(count)]def monte_carlo_pi(iterations: int) -> float:\n    inside_circle = 0\n    for _ in range(iterations):\n        x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n        if x*x + y*y <= 1:\n            inside_circle += 1\n    return 4 * inside_circle / iterations","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def random_walk(steps: int, step_size: float = 1.0) -> List[float]:\n    position = 0\n    walk = [position]\n    for _ in range(steps):\n        step = random.choice([-step_size, step_size])\n        position += step\n        walk.append(position)\n    return walkdef random_matrix(rows: int, cols: int, min_val: float = 0, max_val: float = 1) -> List[List[float]]:\n    return [[random.uniform(min_val, max_val) for _ in range(cols)] for _ in range(rows)]def random_date_range(start_date: datetime.date, end_date: datetime.date) -> datetime.date:\n    time_between = end_date - start_date\n    days_between = time_between.days\n    random_days = random.randrange(days_between)\n    return start_date + datetime.timedelta(days=random_days)def random_color_rgb() -> tuple:\n    return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))def random_permutation(n: int) -> List[int]:\n    return random.sample(range(n), n)def random_boolean_probability(probability: float) -> bool:\n    return random.random() < probabilityif __name__ == \"__main__\":\n    test_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"Original list:\", test_list)\n    print(\"Shuffled:\", shuffle_list(test_list))\n    print(\"Random sample (3):\", random_sample(test_list, 3))\n    print(\"Pi estimate (10000 iterations):\", monte_carlo_pi(10000))\n    print(\"Random walk (10 steps):\", random_walk(10))\n    print(\"Random RGB color:\", random_color_rgb())\n    print(\"Random string:\", generate_random_string(10, True))","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"}],"cluster_id":2,"commit_message":"Add functions for generating random walks, matrices, date ranges, colors, permutations, and boolean values based on probability."},{"affected_files":["commands/gcommit/src/test_impl.py"],"changes":[{"code":"def fibonacci_sequence(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fibdef prime_numbers_up_to(n: int) -> List[int]:\n    if n < 2:\n        return []\n    \n    primes = []\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primesdef factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)def gcd(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return adef lcm(a: int, b: int) -> int:\n    return abs(a * b) // gcd(a, b)def binary_search(arr: List[int], target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def bubble_sort(arr: List[int]) -> List[int]:\n    arr_copy = arr.copy()\n    n = len(arr_copy)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr_copy[j] > arr_copy[j + 1]:\n                arr_copy[j], arr_copy[j + 1] = arr_copy[j + 1], arr_copy[j]\n    return arr_copydef quick_sort(arr: List[int]) -> List[int]:\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)def merge_sort(arr: List[int]) -> List[int]:\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)def merge(left: List[int], right: List[int]) -> List[int]:\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return resultdef is_palindrome(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]def reverse_string(s: str) -> str:\n    return s[::-1]def count_vowels(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def remove_duplicates(arr: List[int]) -> List[int]:\n    return list(set(arr))def find_max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    current_sum = arr[0]\n    \n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sumdef two_sum(arr: List[int], target: int) -> List[int]:\n    num_map = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []def is_anagram(s1: str, s2: str) -> bool:\n    return sorted(s1.lower()) == sorted(s2.lower())def longest_common_subsequence(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]def knapsack_01(weights: List[int], values: List[int], capacity: int) -> int:\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def minimum_spanning_tree_kruskal(edges: List[tuple], num_vertices: int) -> List[tuple]:\n    def find(parent, i):\n        if parent[i] != i:\n            parent[i] = find(parent, parent[i])\n        return parent[i]\n    \n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        \n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    \n    edges.sort(key=lambda x: x[2])  # Sort by weight\n    parent = list(range(num_vertices))\n    rank = [0] * num_vertices\n    mst = []\n    \n    for u, v, weight in edges:\n        if find(parent, u) != find(parent, v):\n            mst.append((u, v, weight))\n            union(parent, rank, u, v)\n    \n    return mstdef longest_increasing_subsequence(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    dp = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def dijkstra_shortest_path(graph: dict, start: str, end: str) -> int:\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    visited = set()\n    \n    while len(visited) < len(graph):\n        current = min((node for node in graph if node not in visited), \n                    key=lambda x: distances[x])\n        visited.add(current)\n        \n        for neighbor, weight in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n    \n    return distances[end] if distances[end] != float('infinity') else -1def depth_first_search(graph: dict, start: str, visited: set = None) -> List[str]:\n    if visited is None:\n        visited = set()\n    \n    visited.add(start)\n    result = [start]\n    \n    for neighbor in graph.get(start, []):\n        if neighbor not in visited:\n            result.extend(depth_first_search(graph, neighbor, visited))\n    \n    return resultdef breadth_first_search(graph: dict, start: str) -> List[str]:\n    visited = set()\n    queue = [start]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            queue.extend(graph.get(node, []))\n    \n    return result","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def topological_sort(graph: dict) -> List[str]:\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] = in_degree.get(neighbor, 0) + 1\n    \n    queue = [node for node in in_degree if in_degree[node] == 0]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        \n        for neighbor in graph.get(node, []):\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return resultdef detect_cycle_directed(graph: dict) -> bool:\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {node: WHITE for node in graph}\n    \n    def dfs(node):\n        color[node] = GRAY\n        for neighbor in graph.get(node, []):\n            if color[neighbor] == GRAY:\n                return True\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n        color[node] = BLACK\n        return False\n    \n    for node in graph:\n        if color[node] == WHITE:\n            if dfs(node):\n                return True\n    return False","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def edit_distance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]def coin_change(coins: List[int], amount: int) -> int:\n    dp = [float('infinity')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('infinity') else -1def house_robber(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev2 = nums[0]\n    prev1 = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        current = max(prev1, prev2 + nums[i])\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1def climbing_stairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def subsets(nums: List[int]) -> List[List[int]]:\n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    result = []\n    backtrack(0, [])\n    return resultdef n_queens(n: int) -> List[List[str]]:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == abs(i - row):\n                return False\n        return True\n    \n    def backtrack(row, board):\n        if row == n:\n            result.append(['.' * col + 'Q' + '.' * (n - col - 1) for col in board])\n            return\n        \n        for col in range(n):\n            if is_safe(board, row, col):\n                board.append(col)\n                backtrack(row + 1, board)\n                board.pop()\n    \n    result = []\n    backtrack(0, [])\n    return resultdef sudoku_solver(board: List[List[str]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        \n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == num:\n                    return False\n        return True","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def unique_paths(m: int, n: int) -> int:\n    dp = [[1] * n for _ in range(m)]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]def word_break(s: str, word_dict: List[str]) -> bool:\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    \n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[len(s)]def generate_parentheses(n: int) -> List[str]:\n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        if open_count < n:\n            backtrack(current + \"(\", open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(current + \")\", open_count, close_count + 1)\n    \n    result = []\n    backtrack(\"\", 0, 0)\n    return result","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    \n    digit_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    def backtrack(index, current):\n        if index == len(digits):\n            result.append(current)\n            return\n        \n        for letter in digit_map[digits[index]]:\n            backtrack(index + 1, current + letter)\n    \n    result = []\n    backtrack(0, \"\")\n    return resultdef combination_sum(candidates: List[int], target: int) -> List[List[int]]:\n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining:\n                current.append(candidates[i])\n                backtrack(i, current, remaining - candidates[i])\n                current.pop()\n    \n    result = []\n    backtrack(0, [], target)\n    return resultdef permutations(nums: List[int]) -> List[List[int]]:\n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for num in nums:\n            if num not in current:\n                current.append(num)\n                backtrack(current)\n                current.pop()\n    \n    result = []\n    backtrack([])\n    return result","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"}],"cluster_id":3,"commit_message":"Add various algorithms implementations: Fibonacci sequence, prime numbers up to a given number, factorial, GCD, LCM, binary search, bubble sort, quick sort, merge sort, palindrome check, reverse string, count vowels, remove duplicates, find max"}]
