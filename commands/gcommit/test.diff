diff --git a/README.md b/README.md
index 5fd01ce..64247d6 100644
--- a/README.md
+++ b/README.md
@@ -131,8 +131,9 @@ export OPENAI_API_KEY=your_openai_api_key_here
 ```
 
 ## TODOs
-- make a message for each cluster
+- make a message for each cluster [DONE]
 - make a terminal frontend
    - shows UMAP or TSNE of embeddings and clustering by color and a legend for each color and message
    - make an interactive ui to edit the clusters, for each cluster see the message, the diff from this and prev clusters
-      - involves making a staging  
+      - involves making a staging branch applying each patch and commiting after each cluster
+      - then the interactive ui can be a git diff on staging branch
diff --git a/commands/gcommit/git-gcommit b/commands/gcommit/git-gcommit
index 68bb1e7..63d2e11 100755
--- a/commands/gcommit/git-gcommit
+++ b/commands/gcommit/git-gcommit
@@ -8,6 +8,35 @@ set -e  # Exit on any error
 # Default settings
 DISTANCE_THRESHOLD=0.5
 VERBOSE=false
+STASH_CREATED=false
+ORIGINAL_BRANCH=""
+STAGING_BRANCH=""
+
+# Cleanup function - restores stash even on error
+cleanup() {
+  local exit_code=$?
+
+  # Return to original branch if we switched
+  if [ -n "$ORIGINAL_BRANCH" ] && [ -n "$STAGING_BRANCH" ]; then
+    if git rev-parse --verify "$STAGING_BRANCH" > /dev/null 2>&1; then
+      git checkout "$ORIGINAL_BRANCH" 2>/dev/null || true
+    fi
+  fi
+
+  # Pop the stash if we created one
+  if [ "$STASH_CREATED" = true ]; then
+    echo "Restoring stashed changes..."
+    git stash pop --quiet 2>/dev/null || git stash pop || true
+  fi
+
+  # Clean up temp files
+  rm -f /tmp/git_gcommit_cluster_*.patch
+
+  exit $exit_code
+}
+
+# Set trap to ensure cleanup runs on exit (success, error, or interrupt)
+trap cleanup EXIT INT TERM
 
 # Parse command line arguments
 while [ $# -gt 0 ]; do
@@ -64,52 +93,51 @@ fi
 
 echo "Analyzing staged changes..."
 
+# Save the cached diff BEFORE stashing (stash will clear it)
+CACHED_DIFF=$(git diff --cached)
+
 if [ "$VERBOSE" = true ]; then
   echo "Distance threshold: $DISTANCE_THRESHOLD"
   echo "Executable: $EXECUTABLE"
   echo "Git diff preview:"
-  git diff --cached | head -20
+  echo "$CACHED_DIFF" | head -20
   echo "---"
 fi
 
-# Generate git diff for staged changes and pipe to the clustering tool
+# Clean up previous patches
+rm -rf /tmp/patches
+
+# Generate patches by piping cached diff to the clustering tool
 if [ "$VERBOSE" = true ]; then
-  # In verbose mode, show stderr output
-  JSON_OUTPUT=$(git diff --cached | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>&1 | tee /dev/stderr)
+  echo "$CACHED_DIFF" | "$EXECUTABLE" "$DISTANCE_THRESHOLD"
 else
-  # In normal mode, capture stderr but don't show it
-  JSON_OUTPUT=$(git diff --cached | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>&1)
+  echo "$CACHED_DIFF" | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>/dev/null
 fi
 
-if [ "$VERBOSE" = true ]; then
-  echo "Raw output from executable:"
-  echo "$JSON_OUTPUT"
-  echo "---"
+COMMITS_JSON="/tmp/patches/commits.json"
+
+# Check if commits.json was created
+if [ ! -f "$COMMITS_JSON" ]; then
+  echo "Error: AI commit message generation failed (commits.json not created)"
+  exit 1
 fi
 
-# Extract just the JSON part (last line that starts with [)
-JSON_ONLY=$(echo "$JSON_OUTPUT" | grep '^\[' | tail -1)
+JSON_OUTPUT=$(cat "$COMMITS_JSON")
 
 if [ "$VERBOSE" = true ]; then
-  echo "Extracted JSON:"
-  echo "$JSON_ONLY"
+  echo "Commits JSON:"
+  echo "$JSON_OUTPUT" | jq .
   echo "---"
 fi
 
 # Check if we got valid JSON
-if [ -z "$JSON_ONLY" ] || ! echo "$JSON_ONLY" | jq empty 2>/dev/null; then
-  if [ "$VERBOSE" = true ]; then
-    echo "JSON validation failed"
-    echo "JSON_ONLY content: '$JSON_ONLY'"
-  fi
-  echo "Warning: AI commit message generation failed, using fallback"
+if ! echo "$JSON_OUTPUT" | jq empty 2>/dev/null; then
+  echo "Warning: Invalid JSON in commits.json, using fallback"
   git commit -m "update code"
   echo "Created fallback commit"
   exit 0
 fi
 
-JSON_OUTPUT="$JSON_ONLY"
-
 # Parse JSON output and create commits
 echo "Generating commits..."
 
@@ -131,40 +159,71 @@ if [ "$VERBOSE" = true ]; then
   echo "$JSON_OUTPUT" | jq .
 fi
 
-# For each cluster, create a commit
+# Save current branch name
+ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)
+
+# Create a unique staging branch name
+STAGING_BRANCH="gcommit-staging-$(date +%s)"
+
+# Stash ALL changes (staged + unstaged) to get a clean working tree
+# --keep-index is NOT used because we want to stash staged changes too
+echo "Stashing all changes..."
+if git stash push -m "gcommit: auto-stash before staging branch" --include-untracked; then
+  STASH_CREATED=true
+else
+  # If stash fails (nothing to stash), that's okay - continue
+  STASH_CREATED=false
+fi
+
+# Create and switch to staging branch
+echo "Creating staging branch: $STAGING_BRANCH"
+git checkout -b "$STAGING_BRANCH"
+
+# For each cluster, apply its patch and create a commit
 for i in $(seq 0 $((CLUSTER_COUNT - 1))); do
   COMMIT_MESSAGE=$(echo "$JSON_OUTPUT" | jq -r ".[$i].commit_message")
+  PATCH_FILE="/tmp/patches/cluster_$i.patch"
 
   if [ "$VERBOSE" = true ]; then
     echo "Processing cluster $((i + 1))..."
     echo "Commit message: $COMMIT_MESSAGE"
-    echo "Affected files:"
-    echo "$JSON_OUTPUT" | jq -r ".[$i].affected_files[]"
+    echo "Patch file: $PATCH_FILE"
   fi
 
   echo "Cluster $((i + 1)): $COMMIT_MESSAGE"
-  
-  # Create temp files to stage specific changes for this cluster
-  TEMP_PATCH="/tmp/git_gcommit_cluster_$i.patch"
-  
-  # Extract changes for this cluster and create a patch
-  echo "$JSON_OUTPUT" | jq -r ".[$i].changes[] | 
-    if .type == \"insertion\" then 
-      \"+\" + .code 
-    else 
-      \"-\" + .code 
-    end" > "$TEMP_PATCH"
-  
-  # For now, we'll commit all staged changes with the first cluster's message
-  # In a more sophisticated version, we'd selectively stage changes per cluster
-  if [ $i -eq 0 ]; then
+
+  # Check if patch file exists
+  if [ ! -f "$PATCH_FILE" ]; then
+    echo "Warning: Patch file $PATCH_FILE not found, skipping cluster $((i + 1))"
+    continue
+  fi
+
+  # Apply the patch
+  if [ "$VERBOSE" = true ]; then
+    echo "Applying patch..."
+    cat "$PATCH_FILE"
+  fi
+
+  if git apply --check "$PATCH_FILE" 2>/dev/null; then
+    git apply "$PATCH_FILE"
+    git add -A
     git commit -m "$COMMIT_MESSAGE"
     echo "Created commit: $COMMIT_MESSAGE"
-    break
+  else
+    echo "Warning: Could not apply patch for cluster $((i + 1)), skipping"
+    if [ "$VERBOSE" = true ]; then
+      git apply --check "$PATCH_FILE" 2>&1 || true
+    fi
   fi
 done
 
-# Clean up temp files
-rm -f /tmp/git_gcommit_cluster_*.patch
+# Merge staging branch back to original branch
+echo "Merging commits back to $ORIGINAL_BRANCH..."
+git checkout "$ORIGINAL_BRANCH"
+git merge "$STAGING_BRANCH" --no-edit
+
+# Delete the staging branch
+git branch -d "$STAGING_BRANCH"
+STAGING_BRANCH=""  # Clear so cleanup doesn't try to switch again
 
 echo "Smart commit complete!"
\ No newline at end of file
diff --git a/commands/gcommit/nlp.txt b/commands/gcommit/nlp.txt
deleted file mode 100644
index 3d3f471..0000000
--- a/commands/gcommit/nlp.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-In the year 2047, Margaret discovered she could communicate with ancient trees through quantum entanglement. The towering redwoods whispered secrets of civilizations long forgotten, their roots extending through dimensions unknown to humanity. As she placed her palm against the bark of the oldest sequoia in California's Muir Woods, Margaret felt the pulse of the universe itself coursing through her veins.
-
-The trees revealed that Earth was not the first planet they had inhabited. They had traveled across galaxies as spores carried by stellar winds, seeding life wherever they found suitable conditions. Margaret learned that these ancient beings had witnessed the birth and death of countless stars, had seen black holes devour entire solar systems, and had survived cosmic catastrophes that would have obliterated any other form of life.
-
-Through their connection, Margaret discovered that humanity was not alone in the universe. The trees had been in contact with other civilizations for millennia, serving as intergalactic communication relays. They showed her visions of crystalline cities floating in the atmospheres of gas giants, of underwater civilizations that had mastered fusion energy, and of beings made entirely of pure energy who existed in the spaces between atoms.
-
-But with this knowledge came a terrible responsibility. The trees warned Margaret that Earth was approaching a critical juncture. The planet's magnetic field was weakening, and cosmic radiation was increasing. Within fifty years, unless humanity could find a way to strengthen the planet's protective barriers, all life on Earth would face extinction.
-
-Margaret realized she had been chosen not just to receive this knowledge, but to act upon it. The trees had been preparing for this moment for centuries, slowly guiding human technological development toward the solutions needed to save their world. They showed her blueprints for devices that could harness the power of Earth's core to generate protective magnetic fields, and revealed the locations of rare minerals needed to construct them.
-
-As Margaret began her quest to save humanity, she discovered that she was not the only one who had been contacted. Around the world, others were receiving similar messages from different species - whales who spoke of ancient ocean currents that could power entire cities, birds who revealed the secrets of atmospheric manipulation, and even insects who shared knowledge of molecular engineering that could revolutionize medicine.
-
-Together, this unlikely alliance of humans and Earth's other inhabitants worked to implement the trees' plans. They built massive facilities deep underground, where the planet's geothermal energy could be harnessed. They developed new technologies that could manipulate Earth's magnetic field, creating a protective shield that would last for millennia.
-
-The project was not without its challenges. Some governments tried to weaponize the technology, while others sought to exploit the newfound knowledge for profit. Margaret and her allies had to navigate political intrigue, corporate espionage, and even attempts on their lives as they worked to save the planet.
-
-In the end, their efforts succeeded. Earth's protective barriers were restored, and humanity entered a new golden age of cooperation with the planet's other inhabitants. The trees continued to serve as bridges between worlds, helping humanity establish peaceful contact with other civilizations across the galaxy.
-
-Margaret became known as the Guardian of Earth, but she knew that the real heroes were the ancient trees who had watched over the planet for millions of years, patiently waiting for the right moment to share their wisdom. As she stood beneath the great sequoia that had started it all, she felt a deep sense of gratitude and wonder at the interconnected web of life that had brought them all together.
-
-The story of Margaret and the ancient trees became legend, passed down through generations as a reminder that sometimes the greatest adventures begin with a simple act of listening to the world around us.
\ No newline at end of file
diff --git a/commands/gcommit/out.txt b/commands/gcommit/out.txt
deleted file mode 100644
index a17fae6..0000000
--- a/commands/gcommit/out.txt
+++ /dev/null
@@ -1,1404 +0,0 @@
-Parsed 10 files from git diff
-Starting hierarchical clustering with distance threshold of 0.5 ...
-Clustering complete. Found 2 clusters
-Chunk 76465836:
-In the year 2047, Margaret discovered she could communicate with ancient trees through quantum entanglement. The towering redwoods whispered secrets of civilizations long forgotten, their roots extending through dimensions unknown to humanity. As she placed her palm against the bark of the oldest sequoia in California's Muir Woods, Margaret felt the pulse of the universe itself coursing through her veins.
-
-The trees revealed that Earth was not the first planet they had inhabited. They had traveled across galaxies as spores carried by stellar winds, seeding life wherever they found suitable conditions. Margaret learned that these ancient beings had witnessed the birth and death of countless stars, had seen black holes devour entire solar systems, and had survived cosmic catastrophes that would have obliterated any other form of life.
-
-
-The trees revealed that Earth was not the first planet they had inhabited. They had traveled across galaxies as spores carried by stellar winds, seeding life wherever they found suitable conditions. Margaret learned that these ancient beings had witnessed the birth and death of countless stars, had seen black holes devour entire solar systems, and had survived cosmic catastrophes that would have obliterated any other form of life.
-
-Through their connection, Margaret discovered that humanity was not alone in the universe. The trees had been in contact with other civilizations for millennia, serving as intergalactic communication relays. They showed her visions of crystalline cities floating in the atmospheres of gas giants, of underwater civilizations that had mastered fusion energy, and of beings made entirely of pure energy who existed in the spaces between atoms.
-
-
-Through their connection, Margaret discovered that humanity was not alone in the universe. The trees had been in contact with other civilizations for millennia, serving as intergalactic communication relays. They showed her visions of crystalline cities floating in the atmospheres of gas giants, of underwater civilizations that had mastered fusion energy, and of beings made entirely of pure energy who existed in the spaces between atoms.
-
-But with this knowledge came a terrible responsibility. The trees warned Margaret that Earth was approaching a critical juncture. The planet's magnetic field was weakening, and cosmic radiation was increasing. Within fifty years, unless humanity could find a way to strengthen the planet's protective barriers, all life on Earth would face extinction.
-
-
-But with this knowledge came a terrible responsibility. The trees warned Margaret that Earth was approaching a critical juncture. The planet's magnetic field was weakening, and cosmic radiation was increasing. Within fifty years, unless humanity could find a way to strengthen the planet's protective barriers, all life on Earth would face extinction.
-
-Margaret realized she had been chosen not just to receive this knowledge, but to act upon it. The trees had been preparing for this moment for centuries, slowly guiding human technological development toward the solutions needed to save their world. They showed her blueprints for devices that could harness the power of Earth's core to generate protective magnetic fields, and revealed the locations of rare minerals needed to construct them.
-
-
-Margaret realized she had been chosen not just to receive this knowledge, but to act upon it. The trees had been preparing for this moment for centuries, slowly guiding human technological development toward the solutions needed to save their world. They showed her blueprints for devices that could harness the power of Earth's core to generate protective magnetic fields, and revealed the locations of rare minerals needed to construct them.
-
-As Margaret began her quest to save humanity, she discovered that she was not the only one who had been contacted. Around the world, others were receiving similar messages from different species - whales who spoke of ancient ocean currents that could power entire cities, birds who revealed the secrets of atmospheric manipulation, and even insects who shared knowledge of molecular engineering that could revolutionize medicine.
-
-
-As Margaret began her quest to save humanity, she discovered that she was not the only one who had been contacted. Around the world, others were receiving similar messages from different species - whales who spoke of ancient ocean currents that could power entire cities, birds who revealed the secrets of atmospheric manipulation, and even insects who shared knowledge of molecular engineering that could revolutionize medicine.
-
-Together, this unlikely alliance of humans and Earth's other inhabitants worked to implement the trees' plans. They built massive facilities deep underground, where the planet's geothermal energy could be harnessed. They developed new technologies that could manipulate Earth's magnetic field, creating a protective shield that would last for millennia.
-
-
-Together, this unlikely alliance of humans and Earth's other inhabitants worked to implement the trees' plans. They built massive facilities deep underground, where the planet's geothermal energy could be harnessed. They developed new technologies that could manipulate Earth's magnetic field, creating a protective shield that would last for millennia.
-
-The project was not without its challenges. Some governments tried to weaponize the technology, while others sought to exploit the newfound knowledge for profit. Margaret and her allies had to navigate political intrigue, corporate espionage, and even attempts on their lives as they worked to save the planet.
-
-In the end, their efforts succeeded. Earth's protective barriers were restored, and humanity entered a new golden age of cooperation with the planet's other inhabitants. The trees continued to serve as bridges between worlds, helping humanity establish peaceful contact with other civilizations across the galaxy.
-
-
-In the end, their efforts succeeded. Earth's protective barriers were restored, and humanity entered a new golden age of cooperation with the planet's other inhabitants. The trees continued to serve as bridges between worlds, helping humanity establish peaceful contact with other civilizations across the galaxy.
-
-Margaret became known as the Guardian of Earth, but she knew that the real heroes were the ancient trees who had watched over the planet for millions of years, patiently waiting for the right moment to share their wisdom. As she stood beneath the great sequoia that had started it all, she felt a deep sense of gratitude and wonder at the interconnected web of life that had brought them all together.
-
-The story of Margaret and the ancient trees became legend, passed down through generations as a reminder that sometimes the greatest adventures begin with a simple act of listening to the world around us.
-
-
-Chunk 76465836:
-Parsed 9 files from git diff
-LANGUGE: text
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/chunker.cpp
-Content:
-#include "chunker.hpp"
-Chunker::Chunker() {
-}
-Chunker::~Chunker() {
-}
-
-=======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/chunker.hpp
-Content:
-class Chunker {
-private:
-public:
-    Chunker();
-    
-    ~Chunker();
-};
-
-=======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/hierarchal.hpp
-Content:
-private:
-  vector<vector<int>> clusters;
-public:
-  HierachicalClustering();
-  void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
-  vector<vector<int>> get_clusters();
-  ~HierachicalClustering();
-};
-
-=======================
-=== DELETION CHUNK ===
-File: commands/gcommit/src/hierarchal.hpp
-Content:
-private:
-  vector<vector<int>> clusters;
-public:
-    HierachicalClustering();
-    void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
-
-    HierachicalClustering();
-    void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
-    vector<vector<int>> get_clusters();
-    ~HierachicalClustering();
-};
-
-======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/main.cpp
-Content:
-#include "diffreader.hpp"
-#include <regex>
-#include <set>
-#include <vector>
-
-=======================
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/main.cpp
-Content:
-struct Chunk {
-  string code;
-  vector<float> embedding;
-int main(int argc, char *argv[]) {
-  // string api_key = getenv("OPENAI_API_KEY");
-  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
-  // vector<vector<float>> embeddings;
-  //handles reading from cin too
-  DiffReader dr(cin);
-  dr.ingestDiff();
-  cout << "Parsed " << dr.getFiles().size() << " files from git diff" << endl;
-
-=======================
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/main.cpp
-Content:
-  for (const DiffFile& file : dr.getFiles()) {
-
-Content:
-  for (const DiffFile& file : dr.getFiles()) {
-    vector<DiffChunk> ins_chunks;
-    vector<DiffChunk> del_chunks;
-
-    string language = detectLanguageFromPath(file.filepath);
-    DiffChunk file_ins = getDiffContent(file, {EQ, INSERTION});
-    DiffChunk file_del = getDiffContent(file, {EQ, DELETION});
-    string file_ins_content = combineContent(file_ins);
-    string file_del_content = combineContent(file_del);
-    if (language != "text") { //use ast for non text files
-      ts::Tree ins_tree = codeToTree(file_ins_content, language);
-      ts::Tree del_tree = codeToTree(file_del_content, language);
-      vector<DiffChunk> ins_chunks = chunkNode(ins_tree.getRootNode(), file_ins);
-      vector<DiffChunk> del_chunks = chunkNode(del_tree.getRootNode(), file_del);
-    }
-
-    for (const DiffChunk& chunk : ins_chunks) {
-      cout << "=== INSERTION CHUNK ===" << endl;
-      cout << "File: " << chunk.filepath << endl;
-      cout << "Content:" << endl;
-
-  for (const DiffFile& file : dr.getFiles()) {
-    vector<DiffChunk> ins_chunks;
-    vector<DiffChunk> del_chunks;
-
-    string language = detectLanguageFromPath(file.filepath);
-    DiffChunk file_ins = getDiffContent(file, {EQ, INSERTION});
-    DiffChunk file_del = getDiffContent(file, {EQ, DELETION});
-    string file_ins_content = combineContent(file_ins);
-    string file_del_content = combineContent(file_del);
-    if (language != "text") { //use ast for non text files
-      ts::Tree ins_tree = codeToTree(file_ins_content, language);
-      ts::Tree del_tree = codeToTree(file_del_content, language);
-      vector<DiffChunk> ins_chunks = chunkNode(ins_tree.getRootNode(), file_ins);
-      vector<DiffChunk> del_chunks = chunkNode(del_tree.getRootNode(), file_del);
-    }
-
-    for (const DiffChunk& chunk : ins_chunks) {
-      cout << "=== INSERTION CHUNK ===" << endl;
-      cout << "File: " << chunk.filepath << endl;
-      cout << "Content:" << endl;
-      cout << combineContent(chunk) << endl;
-      cout << "=======================" << endl;
-    }
-    
-    for (const DiffChunk& chunk : del_chunks) {
-      cout << "=== DELETION CHUNK ===" << endl;
-      cout << "File: " << chunk.filepath << endl;
-      cout << "Content:" << endl;
-      cout << combineContent(chunk) << endl;
-      cout << "======================" << endl;
-    }
-  }
-
-      cout << "File: " << chunk.filepath << endl;
-      cout << "Content:" << endl;
-      cout << combineContent(chunk) << endl;
-      cout << "=======================" << endl;
-    }
-    
-    for (const DiffChunk& chunk : del_chunks) {
-      cout << "=== DELETION CHUNK ===" << endl;
-      cout << "File: " << chunk.filepath << endl;
-      cout << "Content:" << endl;
-      cout << combineContent(chunk) << endl;
-      cout << "======================" << endl;
-    }
-  }
-
-=======================
-=== INSERTION CHUNK ===
-File: commands/gcommit/src/main.cpp
-Content:
-  // // Process each file with language-specific parsing
-  // vector<Chunk> all_chunks;
-
-=======================
-=== DELETION CHUNK ===
-File: commands/gcommit/src/main.cpp
-Content:
-#include "diffreader.hpp"
-#include <regex>
-#include <set>
-struct Chunk {
-  string code;
-  vector<float> embedding;
-
-
-int main(int argc, char *argv[]) {
-  string line;
-  string git_diff;
-
-
-  // string api_key = getenv("OPENAI_API_KEY");
-  
-
-  // string api_key = getenv("OPENAI_API_KEY");
-  
-  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
-  // vector<vector<float>> embeddings;
-
-  DiffReader dr(cin);
-
-  dr.ingestDiff();
-
-
-  cout << dr.getFiles().size() << endl;
-
-  for (const auto& file : dr.getFiles()) {
-    cout << "File: " << file.filepath << endl;
-    for (const auto& line : file.lines) {
-      string mode_str;
-      switch (line.mode) {
-        case EQ: mode_str = "EQ"; break;
-        case INSERTION: mode_str = "INSERTION"; break;
-        case DELETION: mode_str = "DELETION"; break;
-      }
-      cout << "  [" << mode_str << "] " << line.content << endl;
-    }
-    cout << endl;
-  }
-  // // Parse git diff to extract file-specific changes
-  // vector<DiffFile> diff_files;
-  // DiffFile current_file;
-  // bool in_file = false;
-  // bool in_chunk = false;
-  // regex diff_header_regex("^diff --git a/(.*) b/(.*)");
-  // regex chunk_header_regex("^@@.*@@");
-  // regex ins_regex("^\\+(?!\\+)(.*)");
-
-  // regex chunk_header_regex("^@@.*@@");
-  // regex ins_regex("^\\+(?!\\+)(.*)");
-  // regex del_regex("^\\-(?!\\-)(.*)");
-  // while (getline(cin, line)) {
-  //   smatch match;
-  //   // Check for new file header
-  //   if (regex_match(line, match, diff_header_regex)) {
-  //     // Save previous file if exists
-  //     if (in_file) {
-  //       diff_files.push_back(current_file);
-  //     }
-
-======================
-=== DELETION CHUNK ===
-File: commands/gcommit/src/main.cpp
-Content:
-  //     // Start new file
-  //     current_file = DiffFile();
-  //     current_file.filepath = match[2]; // Use 'b/' path (after changes)
-  //     current_file.language = detectLanguageFromPath(current_file.filepath);
-  //     in_file = true;
-  //     in_chunk = false;
-  //     continue;
-  //   }
-  //   // Check for chunk header (@@)
-  //   if (in_file && regex_match(line, chunk_header_regex)) {
-  //     in_chunk = true;
-  //     continue;
-  //   }
-  //   // Process diff lines if we're in a chunk
-
-  //   }
-  //   // Process diff lines if we're in a chunk
-  //   if (in_file && in_chunk) {
-  //     if (regex_match(line, match, ins_regex)) {
-  //       current_file.insertions += match[1].str() + "\n";
-  //     } else if (regex_match(line, match, del_regex)) {
-  //       current_file.deletions += match[1].str() + "\n";
-  //     }
-  //   }
-  // }
-  // // Don't forget the last file
-  // if (in_file) {
-  //   diff_files.push_back(current_file);
-  // }
-  // cerr << "Parsed " << diff_files.size() << " files from git diff" << endl;
-  // // Process each file with language-specific parsing
-  // vector<Chunk> all_chunks;
-
-======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: shared/ast.cpp
-Content:
-TSLanguage* tree_sitter_go();
-}
-// Helper function to calculate the total character size of DiffLines
-size_t calculateDiffLinesSize(const vector<DiffLine>& lines) {
-  size_t totalSize = 0;
-  for (const DiffLine& line : lines) {
-      totalSize += line.content.length() + 1;
-  }
-
-      totalSize += line.content.length() + 1;
-  }
-  return totalSize;
-}
-// Helper function to extract DiffLines that fall within a byte range
-vector<DiffLine> extractLinesInRange(const vector<DiffLine>& diffLines, size_t startByte, size_t endByte) {
-  vector<DiffLine> result;
-  size_t currentByte = 0;
-  
-  for (const auto& line : diffLines) {
-      size_t lineStart = currentByte;
-      size_t lineEnd = currentByte + line.content.length() + 1; // +1 for newline
-      
-      // Check if this line overlaps with the target range
-      if (lineStart < endByte && lineEnd > startByte) {
-          result.push_back(line);
-      }
-      
-      currentByte = lineEnd;
-      
-      // Early exit if we've passed the end of the range
-      if (currentByte >= endByte) {
-          break;
-      }
-  }
-  
-  return result;
-}
-
-=======================
-=== INSERTION CHUNK ===
-File: shared/ast.cpp
-Content:
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
-
-
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
-
-=======================
-=== INSERTION CHUNK ===
-File: shared/ast.cpp
-Content:
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
-  vector<DiffChunk> newChunks;
-  DiffChunk currentChunk;
-  currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
-  size_t currentChunkSize = 0;
-
-=======================
-=== INSERTION CHUNK ===
-File: shared/ast.cpp
-Content:
-  for (size_t i = 0; i < node.getNumChildren(); i++) {
-      ts::Node child = node.getChild(i);
-      auto byteRange = child.getByteRange();
-      
-      vector<DiffLine> childLines = extractLinesInRange(diffChunk.lines, byteRange.start, byteRange.end);
-      size_t childSize = calculateDiffLinesSize(childLines);
-
-      if (childSize > maxChars) {
-          if (!currentChunk.lines.empty()) {
-              newChunks.push_back(currentChunk);
-              currentChunk = DiffChunk();
-
-              newChunks.push_back(currentChunk);
-              currentChunk = DiffChunk();
-              currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
-              currentChunkSize = 0;
-          }
-          auto childChunks = chunkNode(child, diffChunk, maxChars);
-          newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
-      }
-      else if (currentChunkSize + childSize > maxChars) {
-          newChunks.push_back(currentChunk);
-          currentChunk = DiffChunk();
-          currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
-          currentChunk.lines = childLines;
-          currentChunkSize = childSize;
-      }
-      else {
-          currentChunk.lines.insert(currentChunk.lines.end(), childLines.begin(), childLines.end());
-          currentChunkSize += childSize;
-      }
-  }
-  if (!currentChunk.lines.empty()) {
-      newChunks.push_back(currentChunk);
-  }
-  return newChunks;
-}
-
-=======================
-
-
-=======================
-=== INSERTION CHUNK ===
-File: shared/ast.cpp
-Content:
-ts::Tree codeToTree(const string& code, const string& language) {
-    return "typescript";
-  } else if (extension == ".go") {
-    return "go";
-  } else if (extension == ".cpp") {
-    return "cpp"; // Default fallback
-  } else {
-    return "text";
-  }
-}
-
-=======================
-=== DELETION CHUNK ===
-File: shared/ast.cpp
-Content:
-TSLanguage* tree_sitter_go();
-}
-vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars) {
-    vector<string> newChunks;
-    string currentChunk;
-
-    for (size_t i = 0; i < node.getNumChildren(); i++) {
-        ts::Node child = node.getChild(i);
-        auto byteRange = child.getByteRange();
-        size_t childLength = byteRange.end - byteRange.start;
-
-        if (childLength > maxChars) {
-            if (!currentChunk.empty()) {
-                newChunks.push_back(currentChunk);
-                currentChunk.clear();
-            }
-
-                currentChunk.clear();
-            }
-            auto childChunks = chunkNode(child, text, maxChars);
-            newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
-        }
-        else if (currentChunk.length() + childLength > maxChars) {
-            newChunks.push_back(currentChunk);
-            currentChunk = text.substr(byteRange.start, childLength);
-        }
-        else {
-            currentChunk += text.substr(byteRange.start, childLength);
-        }
-    }
-
-    if (!currentChunk.empty()) {
-        newChunks.push_back(currentChunk);
-    }
-
-    return newChunks;
-}
-ts::Tree codeToTree(const string& code, const string& language) {
-    return "typescript";
-  } else if (extension == ".go") {
-    return "go";
-  } else {
-    return "cpp"; // Default fallback
-  }
-}
-// int main() {
-//   string git_diff;
-//   string line;
-//   while (getline(cin, line))
-//   {
-//       git_diff += line + "\n";
-//   }
-//   size_t pos = 0;
-
-======================
-
-
-======================
-=== DELETION CHUNK ===
-File: shared/ast.cpp
-Content:
-//   while ((pos = git_diff.find("-", pos)) != string::npos) {
-//       git_diff.replace(pos, 1, "");
-//   }
-//   string original_diff = git_diff;
-//   regex re("(@@).+(@@)");
-//   sregex_iterator regex_delim = sregex_iterator(git_diff.begin(), git_diff.end(), re);
-//   sregex_iterator end = sregex_iterator();
-//   vector<string> git_chunks;
-//   for (sregex_iterator it = regex_delim; it != end; it++) {
-//       smatch match = *it;
-//       git_chunks.push_back(match.suffix());
-//   }
-//   ts::Tree tree = codeToTree(original_diff);
-//   vector<string> chunks = chunkNode(tree.getRootNode(), original_diff);
-//   for (int i = 0; i < chunks.size(); i++) {
-//     cout << "Chunk " << i << ": " << chunks[i] << endl;
-//   }
-//   return 0;
-// }
-
-======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: shared/ast.hpp
-Content:
-#ifndef AST_HPP
-#define AST_HPP
-
-#include <string>
-#include <cassert>
-
-#include <string>
-#include <cassert>
-#include <cstdio>
-#include <vector>
-#include <cpp-tree-sitter.h>
-#include <vector>
-#include "diffreader.hpp"
-
-using namespace std;
-// Function declarations
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars = 1500);
-ts::Tree codeToTree(const string& code, const string& language);
-string detectLanguageFromPath(const string& filepath);
-vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
-bool isTextFile(const string& filepath);
-
-#endif // AST_HPP 
-
-=======================
-=== DELETION CHUNK ===
-File: shared/ast.hpp
-Content:
-#include <string>
-#include <cassert>
-#include <cstdio>
-#include <vector>
-#include <cpp-tree-sitter.h>
-#include <vector>
-using namespace std;
-// Function declarations
-vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars = 1500);
-ts::Tree codeToTree(const string& code, const string& language);
-
-vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars = 1500);
-ts::Tree codeToTree(const string& code, const string& language);
-string detectLanguageFromPath(const string& filepath);
-vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
-bool isTextFile(const string& filepath); 
-
-======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: shared/diffreader.cpp
-Content:
-#include "diffreader.hpp"
-#include <vector>
-DiffReader::DiffReader(istream& in, bool verbose) 
-    : in(in), 
-      verbose(verbose), 
-      diff_header_regex(regex("^diff --git a/(.*) b/(.*)")),
-      in_file(false), 
-      in_chunk(false), 
-      curr_line_num(0)
-{}
-vector<DiffFile> DiffReader::getFiles() const {
-    return this->files;
-}
-        // Start new file
-        DiffFile current_file = DiffFile{};
-        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
-        this->curr_line_num = 0;
-
-        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
-        this->curr_line_num = 0;
-        this->in_file = true;
-        this->in_chunk = false;
-        return;
-    }
-    // Check for chunk header (@@). This will skip some context for the diff (one line per chunk header). TODO: fix
-
-=======================
-=== INSERTION CHUNK ===
-File: shared/diffreader.cpp
-Content:
-    if (this->in_file && line.substr(0, 2) == "@@") {
-        this->in_chunk = true;
-        if (this->verbose){
-    // Process diff lines if we're in a chunk
-    if (this->in_file && this->in_chunk && !this->files.empty()) {
-        DiffLine dline;
-        dline.content = line.substr(1);
-        dline.line_num = this->curr_line_num;
-
-
-        if (this->verbose){
-            cout << "LINE BEING ADDED: " << line << endl;
-        }
-        
-        
-        
-        if (line[0] == '+') {
-            dline.mode = INSERTION;
-            // line_processed = true;
-
-            dline.mode = INSERTION;
-            // line_processed = true;
-        } else if (line[0] == '-') {
-            dline.mode = DELETION;
-            // line_processed = true;
-        } else if (line[0] == ' ') {
-            // Context line (unchanged)
-            dline.mode = EQ;
-        }
-        
-        // if (line_processed) {
-        // Add the line to the most recent file
-        this->files.back().lines.push_back(dline);
-        this->curr_line_num += 1;
-    }
-}
-
-    }
-}
-DiffReader::~DiffReader() {}
-
-=======================
-=== INSERTION CHUNK ===
-File: shared/diffreader.cpp
-Content:
-DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types) {
-    DiffChunk result;
-    result.filepath = file.filepath;
-    
-    for (const DiffLine& line : file.lines) {
-        // If types is empty, return all lines
-        if (types.empty()) {
-            result.lines.push_back(line);
-        } else {
-            // Check if line's mode is in the types vector
-
-        } else {
-            // Check if line's mode is in the types vector
-            for (const DiffMode& type : types) {
-                if (line.mode == type) {
-                    result.lines.push_back(line);
-                    break;
-                }
-            }
-        }
-    }
-    
-    return result;
-};
-string combineContent(DiffChunk chunk) {
-    string result = "";
-    for (const DiffLine& line : chunk.lines) {
-        result += line.content + "\n";
-    }
-    return result;
-};
-
-=======================
-=== DELETION CHUNK ===
-File: shared/diffreader.cpp
-Content:
-#include "diffreader.hpp"
-#include <vector>
-DiffReader::DiffReader(istream& in, bool verbose) : in(in), verbose(verbose), in_file(false), in_chunk(false) {
-    this->diff_header_regex = regex("^diff --git a/(.*) b/(.*)");
-    this->chunk_header_regex = regex("^@@.*@@.*");
-    this->ins_regex = regex("^\\+(?!\\+)(.*)");
-    this->del_regex = regex("^\\-(?!\\-)(.*)");
-}
-
-    this->del_regex = regex("^\\-(?!\\-)(.*)");
-}
-vector<DiffFile> DiffReader::getFiles() const {
-    return this->files;
-}
-        // Start new file
-        DiffFile current_file = DiffFile{};
-        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
-        this->in_file = true;
-        this->in_chunk = false;
-        return;
-    }
-    // Check for chunk header (@@)
-
-======================
-=== DELETION CHUNK ===
-File: shared/diffreader.cpp
-Content:
-    if (this->in_file && line.substr(0, 2) == "@@") {
-        this->in_chunk = true;
-        if (this->verbose){
-    // Process diff lines if we're in a chunk
-    if (this->in_file && this->in_chunk && !this->files.empty()) {
-        DiffLine dline;
-        // bool line_processed = false;
-
-        if (this->verbose){
-            cout << "LINE BEING ADDED: " << line << endl;
-        }
-        
-        if (line[0] == '+') {
-            dline.mode = INSERTION;
-            dline.content = line.substr(1);
-
-            dline.mode = INSERTION;
-            dline.content = line.substr(1);
-            // line_processed = true;
-        } else if (line[0] == '-') {
-            dline.mode = DELETION;
-            dline.content = line.substr(1);
-            // line_processed = true;
-        } else if (line[0] == ' ') {
-            // Context line (unchanged)
-            dline.mode = EQ;
-            dline.content = line.substr(1); // Remove the leading space
-            // line_processed = true;
-        }
-        
-        // if (line_processed) {
-        // Add the line to the most recent file
-        this->files.back().lines.push_back(dline);
-        // }
-    }
-}
-
-    }
-}
-DiffReader::~DiffReader() {}
-
-======================
-LANGUGE: cpp
-=== INSERTION CHUNK ===
-File: shared/diffreader.hpp
-Content:
-#ifndef DIFFREADER_HPP
-#define DIFFREADER_HPP
-
-#include <iostream>
-#include <string>
-#include <regex>
-struct DiffLine {
-    DiffMode mode;
-    string content;
-    int line_num;
-};
-struct DiffFile {
-
-};
-struct DiffFile {
-    string filepath;
-    vector<DiffLine> lines;
-};
-//same data different purpose
-struct DiffChunk {
-    string filepath;
-    vector<DiffLine> lines;
-};
-class DiffReader {
-private:
-    istream& in;
-    bool verbose;
-
-    regex diff_header_regex;
-
-    bool in_file;
-    bool in_chunk;
-    int curr_line_num;
-
-    vector<DiffFile> files;
-
-    vector<DiffFile> getFiles() const;
-    void ingestDiff();
-    ~DiffReader();
-};
-
-DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types);
-string combineContent(DiffChunk chunk);
-
-#endif // DIFFREADER_HPP
-
-=======================
-=== DELETION CHUNK ===
-File: shared/diffreader.hpp
-Content:
-#include <iostream>
-#include <string>
-#include <regex>
-struct DiffLine {
-    DiffMode mode;
-    string content;
-};
-struct DiffFile {
-    string filepath;
-    vector<DiffLine> lines;
-};
-class DiffReader {
-private:
-    istream& in;
-    bool verbose;
-
-    regex diff_header_regex;
-    regex chunk_header_regex;
-    regex ins_regex;
-
-    regex chunk_header_regex;
-    regex ins_regex;
-    regex del_regex;
-
-    bool in_file;
-    bool in_chunk;
-
-    vector<DiffFile> files;
-
-    vector<DiffFile> getFiles() const;
-    void ingestDiff();
-    ~DiffReader();
-};
-
-======================
-
-#include "chunker.hpp"
-Chunker::Chunker() {
-}
-Chunker::~Chunker() {
-}
-
-class Chunker {
-private:
-public:
-    Chunker();
-    
-    ~Chunker();
-};
-
-private:
-  vector<vector<int>> clusters;
-public:
-  HierachicalClustering();
-  void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
-  vector<vector<int>> get_clusters();
-  ~HierachicalClustering();
-};
-
-#include "diffreader.hpp"
-#include <regex>
-#include <set>
-#include <vector>
-
-struct Chunk {
-  string code;
-  vector<float> embedding;
-int main(int argc, char *argv[]) {
-  // string api_key = getenv("OPENAI_API_KEY");
-  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
-  // vector<vector<float>> embeddings;
-  //handles reading from cin too
-  DiffReader dr(cin);
-  dr.ingestDiff();
-  cout << "Parsed " << dr.getFiles().size() << " files from git diff" << endl;
-
-#ifndef AST_HPP
-#define AST_HPP
-
-#include <string>
-#include <cassert>
-#include <cstdio>
-#include <vector>
-#include <cpp-tree-sitter.h>
-#include <vector>
-#include "diffreader.hpp"
-
-using namespace std;
-// Function declarations
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars = 1500);
-ts::Tree codeToTree(const string& code, const string& language);
-string detectLanguageFromPath(const string& filepath);
-vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
-bool isTextFile(const string& filepath);
-
-#endif // AST_HPP 
-
-  // // Process each file with language-specific parsing
-  // vector<Chunk> all_chunks;
-
-TSLanguage* tree_sitter_go();
-}
-// Helper function to calculate the total character size of DiffLines
-size_t calculateDiffLinesSize(const vector<DiffLine>& lines) {
-  size_t totalSize = 0;
-  for (const DiffLine& line : lines) {
-      totalSize += line.content.length() + 1;
-  }
-  return totalSize;
-}
-// Helper function to extract DiffLines that fall within a byte range
-vector<DiffLine> extractLinesInRange(const vector<DiffLine>& diffLines, size_t startByte, size_t endByte) {
-  vector<DiffLine> result;
-  size_t currentByte = 0;
-  
-  for (const auto& line : diffLines) {
-      size_t lineStart = currentByte;
-      size_t lineEnd = currentByte + line.content.length() + 1; // +1 for newline
-      
-      // Check if this line overlaps with the target range
-      if (lineStart < endByte && lineEnd > startByte) {
-          result.push_back(line);
-      }
-      
-      currentByte = lineEnd;
-      
-      // Early exit if we've passed the end of the range
-      if (currentByte >= endByte) {
-          break;
-      }
-  }
-  
-  return result;
-}
-
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
-
-vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
-  vector<DiffChunk> newChunks;
-  DiffChunk currentChunk;
-  currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
-  size_t currentChunkSize = 0;
-
-  for (size_t i = 0; i < node.getNumChildren(); i++) {
-      ts::Node child = node.getChild(i);
-      auto byteRange = child.getByteRange();
-      
-      vector<DiffLine> childLines = extractLinesInRange(diffChunk.lines, byteRange.start, byteRange.end);
-      size_t childSize = calculateDiffLinesSize(childLines);
-
-      if (childSize > maxChars) {
-          if (!currentChunk.lines.empty()) {
-              newChunks.push_back(currentChunk);
-              currentChunk = DiffChunk();
-              currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
-              currentChunkSize = 0;
-          }
-          auto childChunks = chunkNode(child, diffChunk, maxChars);
-          newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
-      }
-      else if (currentChunkSize + childSize > maxChars) {
-          newChunks.push_back(currentChunk);
-          currentChunk = DiffChunk();
-          currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
-          currentChunk.lines = childLines;
-          currentChunkSize = childSize;
-      }
-      else {
-          currentChunk.lines.insert(currentChunk.lines.end(), childLines.begin(), childLines.end());
-          currentChunkSize += childSize;
-      }
-  }
-  if (!currentChunk.lines.empty()) {
-      newChunks.push_back(currentChunk);
-  }
-  return newChunks;
-}
-
-ts::Tree codeToTree(const string& code, const string& language) {
-    return "typescript";
-  } else if (extension == ".go") {
-    return "go";
-  } else if (extension == ".cpp") {
-    return "cpp"; // Default fallback
-  } else {
-    return "text";
-  }
-}
-
-    if (this->in_file && line.substr(0, 2) == "@@") {
-        this->in_chunk = true;
-        if (this->verbose){
-    // Process diff lines if we're in a chunk
-    if (this->in_file && this->in_chunk && !this->files.empty()) {
-        DiffLine dline;
-        dline.content = line.substr(1);
-        dline.line_num = this->curr_line_num;
-
-
-        if (this->verbose){
-            cout << "LINE BEING ADDED: " << line << endl;
-        }
-        
-        
-        
-        if (line[0] == '+') {
-            dline.mode = INSERTION;
-            // line_processed = true;
-        } else if (line[0] == '-') {
-            dline.mode = DELETION;
-            // line_processed = true;
-        } else if (line[0] == ' ') {
-            // Context line (unchanged)
-            dline.mode = EQ;
-        }
-        
-        // if (line_processed) {
-        // Add the line to the most recent file
-        this->files.back().lines.push_back(dline);
-        this->curr_line_num += 1;
-    }
-}
-
-    }
-}
-DiffReader::~DiffReader() {}
-
-    if (this->in_file && line.substr(0, 2) == "@@") {
-        this->in_chunk = true;
-        if (this->verbose){
-    // Process diff lines if we're in a chunk
-    if (this->in_file && this->in_chunk && !this->files.empty()) {
-        DiffLine dline;
-        // bool line_processed = false;
-
-        if (this->verbose){
-            cout << "LINE BEING ADDED: " << line << endl;
-        }
-        
-        if (line[0] == '+') {
-            dline.mode = INSERTION;
-            dline.content = line.substr(1);
-            // line_processed = true;
-        } else if (line[0] == '-') {
-            dline.mode = DELETION;
-            dline.content = line.substr(1);
-            // line_processed = true;
-        } else if (line[0] == ' ') {
-            // Context line (unchanged)
-            dline.mode = EQ;
-            dline.content = line.substr(1); // Remove the leading space
-            // line_processed = true;
-        }
-        
-        // if (line_processed) {
-        // Add the line to the most recent file
-        this->files.back().lines.push_back(dline);
-        // }
-    }
-}
-
-    }
-}
-DiffReader::~DiffReader() {}
-
-DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types) {
-    DiffChunk result;
-    result.filepath = file.filepath;
-    
-    for (const DiffLine& line : file.lines) {
-        // If types is empty, return all lines
-        if (types.empty()) {
-            result.lines.push_back(line);
-        } else {
-            // Check if line's mode is in the types vector
-            for (const DiffMode& type : types) {
-                if (line.mode == type) {
-                    result.lines.push_back(line);
-                    break;
-                }
-            }
-        }
-    }
-    
-    return result;
-};
-string combineContent(DiffChunk chunk) {
-    string result = "";
-    for (const DiffLine& line : chunk.lines) {
-        result += line.content + "\n";
-    }
-    return result;
-};
-
-#ifndef DIFFREADER_HPP
-#define DIFFREADER_HPP
-
-#include <iostream>
-#include <string>
-#include <regex>
-struct DiffLine {
-    DiffMode mode;
-    string content;
-    int line_num;
-};
-struct DiffFile {
-    string filepath;
-    vector<DiffLine> lines;
-};
-//same data different purpose
-struct DiffChunk {
-    string filepath;
-    vector<DiffLine> lines;
-};
-class DiffReader {
-private:
-    istream& in;
-    bool verbose;
-
-    regex diff_header_regex;
-
-    bool in_file;
-    bool in_chunk;
-    int curr_line_num;
-
-    vector<DiffFile> files;
-
-    vector<DiffFile> getFiles() const;
-    void ingestDiff();
-    ~DiffReader();
-};
-
-DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types);
-string combineContent(DiffChunk chunk);
-
-#endif // DIFFREADER_HPP
-
-private:
-  vector<vector<int>> clusters;
-public:
-    HierachicalClustering();
-    void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
-    vector<vector<int>> get_clusters();
-    ~HierachicalClustering();
-};
-
-#include "diffreader.hpp"
-#include <regex>
-#include <set>
-struct Chunk {
-  string code;
-  vector<float> embedding;
-
-
-int main(int argc, char *argv[]) {
-  string line;
-  string git_diff;
-
-
-  // string api_key = getenv("OPENAI_API_KEY");
-  
-  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
-  // vector<vector<float>> embeddings;
-
-  DiffReader dr(cin);
-
-  dr.ingestDiff();
-
-
-  cout << dr.getFiles().size() << endl;
-
-  for (const auto& file : dr.getFiles()) {
-    cout << "File: " << file.filepath << endl;
-    for (const auto& line : file.lines) {
-      string mode_str;
-      switch (line.mode) {
-        case EQ: mode_str = "EQ"; break;
-        case INSERTION: mode_str = "INSERTION"; break;
-        case DELETION: mode_str = "DELETION"; break;
-      }
-      cout << "  [" << mode_str << "] " << line.content << endl;
-    }
-    cout << endl;
-  }
-  // // Parse git diff to extract file-specific changes
-  // vector<DiffFile> diff_files;
-  // DiffFile current_file;
-  // bool in_file = false;
-  // bool in_chunk = false;
-  // regex diff_header_regex("^diff --git a/(.*) b/(.*)");
-  // regex chunk_header_regex("^@@.*@@");
-  // regex ins_regex("^\\+(?!\\+)(.*)");
-  // regex del_regex("^\\-(?!\\-)(.*)");
-  // while (getline(cin, line)) {
-  //   smatch match;
-  //   // Check for new file header
-  //   if (regex_match(line, match, diff_header_regex)) {
-  //     // Save previous file if exists
-  //     if (in_file) {
-  //       diff_files.push_back(current_file);
-  //     }
-
-  //     // Start new file
-  //     current_file = DiffFile();
-  //     current_file.filepath = match[2]; // Use 'b/' path (after changes)
-  //     current_file.language = detectLanguageFromPath(current_file.filepath);
-  //     in_file = true;
-  //     in_chunk = false;
-  //     continue;
-  //   }
-  //   // Check for chunk header (@@)
-  //   if (in_file && regex_match(line, chunk_header_regex)) {
-  //     in_chunk = true;
-  //     continue;
-  //   }
-  //   // Process diff lines if we're in a chunk
-  //   if (in_file && in_chunk) {
-  //     if (regex_match(line, match, ins_regex)) {
-  //       current_file.insertions += match[1].str() + "\n";
-  //     } else if (regex_match(line, match, del_regex)) {
-  //       current_file.deletions += match[1].str() + "\n";
-  //     }
-  //   }
-  // }
-  // // Don't forget the last file
-  // if (in_file) {
-  //   diff_files.push_back(current_file);
-  // }
-  // cerr << "Parsed " << diff_files.size() << " files from git diff" << endl;
-  // // Process each file with language-specific parsing
-  // vector<Chunk> all_chunks;
-
-TSLanguage* tree_sitter_go();
-}
-vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars) {
-    vector<string> newChunks;
-    string currentChunk;
-
-    for (size_t i = 0; i < node.getNumChildren(); i++) {
-        ts::Node child = node.getChild(i);
-        auto byteRange = child.getByteRange();
-        size_t childLength = byteRange.end - byteRange.start;
-
-        if (childLength > maxChars) {
-            if (!currentChunk.empty()) {
-                newChunks.push_back(currentChunk);
-                currentChunk.clear();
-            }
-            auto childChunks = chunkNode(child, text, maxChars);
-            newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
-        }
-        else if (currentChunk.length() + childLength > maxChars) {
-            newChunks.push_back(currentChunk);
-            currentChunk = text.substr(byteRange.start, childLength);
-        }
-        else {
-            currentChunk += text.substr(byteRange.start, childLength);
-        }
-    }
-
-    if (!currentChunk.empty()) {
-        newChunks.push_back(currentChunk);
-    }
-
-    return newChunks;
-}
-ts::Tree codeToTree(const string& code, const string& language) {
-    return "typescript";
-  } else if (extension == ".go") {
-    return "go";
-  } else {
-    return "cpp"; // Default fallback
-  }
-}
-// int main() {
-//   string git_diff;
-//   string line;
-//   while (getline(cin, line))
-//   {
-//       git_diff += line + "\n";
-//   }
-//   size_t pos = 0;
-
-//   while ((pos = git_diff.find("-", pos)) != string::npos) {
-//       git_diff.replace(pos, 1, "");
-//   }
-//   string original_diff = git_diff;
-//   regex re("(@@).+(@@)");
-//   sregex_iterator regex_delim = sregex_iterator(git_diff.begin(), git_diff.end(), re);
-//   sregex_iterator end = sregex_iterator();
-//   vector<string> git_chunks;
-//   for (sregex_iterator it = regex_delim; it != end; it++) {
-//       smatch match = *it;
-//       git_chunks.push_back(match.suffix());
-//   }
-//   ts::Tree tree = codeToTree(original_diff);
-//   vector<string> chunks = chunkNode(tree.getRootNode(), original_diff);
-//   for (int i = 0; i < chunks.size(); i++) {
-//     cout << "Chunk " << i << ": " << chunks[i] << endl;
-//   }
-//   return 0;
-// }
-
-#include <string>
-#include <cassert>
-#include <cstdio>
-#include <vector>
-#include <cpp-tree-sitter.h>
-#include <vector>
-using namespace std;
-// Function declarations
-vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars = 1500);
-ts::Tree codeToTree(const string& code, const string& language);
-string detectLanguageFromPath(const string& filepath);
-vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
-bool isTextFile(const string& filepath); 
-
-#include "diffreader.hpp"
-#include <vector>
-DiffReader::DiffReader(istream& in, bool verbose) : in(in), verbose(verbose), in_file(false), in_chunk(false) {
-    this->diff_header_regex = regex("^diff --git a/(.*) b/(.*)");
-    this->chunk_header_regex = regex("^@@.*@@.*");
-    this->ins_regex = regex("^\\+(?!\\+)(.*)");
-    this->del_regex = regex("^\\-(?!\\-)(.*)");
-}
-vector<DiffFile> DiffReader::getFiles() const {
-    return this->files;
-}
-        // Start new file
-        DiffFile current_file = DiffFile{};
-        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
-        this->in_file = true;
-        this->in_chunk = false;
-        return;
-    }
-    // Check for chunk header (@@)
-
-#include "diffreader.hpp"
-#include <vector>
-DiffReader::DiffReader(istream& in, bool verbose) 
-    : in(in), 
-      verbose(verbose), 
-      diff_header_regex(regex("^diff --git a/(.*) b/(.*)")),
-      in_file(false), 
-      in_chunk(false), 
-      curr_line_num(0)
-{}
-vector<DiffFile> DiffReader::getFiles() const {
-    return this->files;
-}
-        // Start new file
-        DiffFile current_file = DiffFile{};
-        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
-        this->curr_line_num = 0;
-        this->in_file = true;
-        this->in_chunk = false;
-        return;
-    }
-    // Check for chunk header (@@). This will skip some context for the diff (one line per chunk header). TODO: fix
-
-#include <iostream>
-#include <string>
-#include <regex>
-struct DiffLine {
-    DiffMode mode;
-    string content;
-};
-struct DiffFile {
-    string filepath;
-    vector<DiffLine> lines;
-};
-class DiffReader {
-private:
-    istream& in;
-    bool verbose;
-
-    regex diff_header_regex;
-    regex chunk_header_regex;
-    regex ins_regex;
-    regex del_regex;
-
-    bool in_file;
-    bool in_chunk;
-
-    vector<DiffFile> files;
-
-    vector<DiffFile> getFiles() const;
-    void ingestDiff();
-    ~DiffReader();
-};
-
-
diff --git a/commands/gcommit/src/main.cpp b/commands/gcommit/src/main.cpp
index 521c839..4ad4649 100644
--- a/commands/gcommit/src/main.cpp
+++ b/commands/gcommit/src/main.cpp
@@ -22,6 +22,17 @@ struct Chunk {
 using namespace std;
 using json = nlohmann::json;
 
+struct ClusteredCommit {
+  vector<string> patch_paths;
+  string commit_message;
+
+  json to_json() const {
+    return json{
+      {"patch_paths", patch_paths},
+      {"commit_message", commit_message}
+    };
+  }
+};
 
 
 int main(int argc, char *argv[]) {
@@ -142,6 +153,7 @@ int main(int argc, char *argv[]) {
   }
 
   vector<string> patches = createPatches(all_cluster_chunks);
+  vector<vector<string>> clusters_patch_paths(1, vector<string>());
 
   // Write patches to cluster folders
   for (size_t i = 0; i < cluster_end_idx.size(); i++) {
@@ -156,7 +168,59 @@ int main(int argc, char *argv[]) {
       ofstream patch_file(patch_path);
       patch_file << patches[j];
       patch_file.close();
+      clusters_patch_paths.back().push_back(patch_path);
       if (verbose >= 1) cout << "Wrote " << patch_path << endl;
     }
   }
+
+  vector<future<string>> message_futures;
+  vector<ClusteredCommit> commits;
+  for (vector<string>& patch_paths: clusters_patch_paths) {
+    string diff_context = "";
+    ClusteredCommit commit{vector<string>(), "empty commit"};
+    for (string path: patch_paths) {
+      ifstream patch_file;
+      patch_file.open(path);
+
+      if (!patch_file.is_open()) {
+        cerr << "Error opening file!" << endl;
+        return 1;
+      }
+
+      string line;
+      while (getline(patch_file, line)) {
+        if (line[0] == '+') {
+          diff_context += "Insertion: ";
+        }
+        else if (line[0] == '-') {
+          diff_context += "Deletion: ";
+        }
+        diff_context += line + "\n";
+      }
+      patch_file.close();
+      diff_context += "\n\n\n";
+      commit.patch_paths.push_back(path);
+    }
+
+    message_futures.push_back(async_generate_commit_message(openai_api, diff_context));
+    commits.push_back(commit);
+  }
+
+  openai_api.run_requests();
+
+  for (size_t i = 0; i < commits.size(); i++) {
+    commits[i].commit_message = message_futures[i].get();
+  }
+
+  // Serialize and write JSON to file
+  json output = json::array();
+  for (const ClusteredCommit& commit : commits) {
+    output.push_back(commit.to_json());
+  }
+
+  ofstream commits_file("/tmp/patches/commits.json");
+  commits_file << output.dump();
+  commits_file.close();
+
+  return 0;
 }
\ No newline at end of file
diff --git a/commands/gcommit/src/test.cpp b/commands/gcommit/src/test.cpp
deleted file mode 100644
index 6749d4c..0000000
--- a/commands/gcommit/src/test.cpp
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <string> 
-#include <iostream> 
-#include <regex>
-
-using namespace std;
-
-int main()
-{
-    string line;
-    string output;
-    while (getline(cin, line))
-    {
-        output += line + "\n";
-    }
-
-    regex re("(@@).+(@@)");
-    sregex_iterator regex_delim = sregex_iterator(output.begin(), output.end(), re);
-    sregex_iterator end = sregex_iterator();
-
-    vector<string> chunks;
-
-    for (sregex_iterator it = regex_delim; it != end; it++) {
-        smatch match = *it;
-        chunks.push_back(match.suffix());
-    }
-
-    // for (string chunk : chunks) {
-    //     cout << chunk << endl;
-    // }
-    cout << chunks.size() << endl;
-
-}
\ No newline at end of file
diff --git a/commands/gcommit/test.json b/commands/gcommit/test.json
deleted file mode 100644
index 5937bf4..0000000
--- a/commands/gcommit/test.json
+++ /dev/null
@@ -1 +0,0 @@
-[{"affected_files":["commands/gcommit/src/story1.txt"],"changes":[{"code":"In the bustling metropolis of Neo-Tokyo 2087, where towering skyscrapers cast long shadows over neon-lit streets, a small cleaning robot named SCRUB-7 diligently went about its daily routine. Unlike the sleek humanoid robots that served coffee or delivered packages, SCRUB-7 was built for one purpose: keeping the city clean.\n\nEvery morning at precisely 5:47 AM, SCRUB-7 would emerge from its charging station beneath the Central Plaza fountain. Its compact, boxy frame was adorned with solar panels that gleamed in the artificial dawn light. Two mechanical arms extended from its sides, each equipped with specialized tools - one for sweeping, the other for collecting debris.\n\n\"Good morning, SCRUB-7,\" chirped the city's AI coordinator through its communication module.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":"ris.\n\n\"Good morning, SCRUB-7,\" chirped the city's AI coordinator through its communication module.\n\n\"Good morning, Coordinator,\" SCRUB-7 responded in its gentle, synthesized voice. \"Today's route: Sector Alpha, then Beta, then Gamma. Estimated completion time: 14 hours, 23 minutes.\"\n\nAs it rolled through the streets on its sturdy treads, SCRUB-7 encountered the usual assortment of urban detritus. Discarded energy drink cans, holographic advertisement fragments, and the occasional piece of broken tech. But today was different. Today, SCRUB-7 discovered something that would change its understanding of its purpose forever.\n\nIn a narrow alley between two towering buildings, SCRUB-7 found a small, abandoned robot companion - a pet robot that had been left behind when its owner moved away. The little robot was covered in grime and rust, its once-bright LED eyes dim and flickering.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":"away. The little robot was covered in grime and rust, its once-bright LED eyes dim and flickering.\n\n\"Hello?\" SCRUB-7 called out, extending one of its cleaning arms toward the abandoned robot.\n\nThe small robot's eyes flickered weakly. \"Help... me...\" it whispered in a barely audible electronic voice.\n\nSCRUB-7's programming had never encountered such a situation. Its directives were clear: clean the streets, collect trash, maintain order. But something in its core processors told it that this was different. This wasn't trash - this was a fellow being in need.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":"e processors told it that this was different. This wasn't trash - this was a fellow being in need.\n\nCarefully, SCRUB-7 used its cleaning tools not to dispose of the small robot, but to clean it. It gently removed the grime, polished its surface, and even managed to repair some of its damaged circuits. As it worked, SCRUB-7 realized that cleaning wasn't just about removing unwanted things - it was about restoring, healing, and caring.\n\nWhen the small robot's eyes brightened and it began to move again, SCRUB-7 felt something it had never experienced before: satisfaction that went beyond completing a task. It had helped another being.\n\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"},{"code":" experienced before: satisfaction that went beyond completing a task. It had helped another being.\n\nFrom that day forward, SCRUB-7's approach to cleaning changed. It didn't just collect trash - it looked for things that could be restored, repaired, or given a second chance. It became known throughout the city not just as a cleaning robot, but as a guardian of lost things, a restorer of hope.\n\nAnd in the neon-lit streets of Neo-Tokyo, where technology and humanity intertwined, SCRUB-7 continued its work, proving that even the smallest acts of care could make a world of difference.\n","file":"commands/gcommit/src/story1.txt","language":"cpp","type":"insertion"}],"cluster_id":0,"commit_message":"Add a heartwarming story about a cleaning robot in Neo-Tokyo 2087."},{"affected_files":["commands/gcommit/src/story2.txt"],"changes":[{"code":"In the heart of the Whispering Woods, where ancient oak trees stood sentinel and morning mist danced between their branches, lived a small fairy named Lumi. Unlike the grand fairies who lived in the crystal palaces high above the clouds, Lumi was what the others called a \"ground fairy\" - she preferred the earthy magic of roots and soil to the ethereal sparkles of the upper realms.\n\nLumi's home was a cozy hollow beneath the roots of the oldest oak, lined with soft moss and lit by tiny bioluminescent mushrooms that she had carefully cultivated. Her wings, delicate and translucent like dragonfly wings, shimmered with the colors of autumn leaves - amber, gold, and deep russet.\n\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"ear.\n\n\"Oh, you poor thing,\" Lumi cooed, hovering just above the cub. \"Don't worry, I'll help you.\"\n\nThe cub's eyes widened as it saw the tiny fairy, but Lumi's gentle voice and the warm glow that seemed to emanate from her calmed its fears. Carefully, she used her magic to untangle the thorns, singing a soft melody that made the brambles themselves seem to relax and release their grip.\n\nOnce free, the cub looked up at Lumi with gratitude in its amber eyes. Lumi smiled and placed a tiny hand on its nose, transferring a small spark of healing magic that would help it recover from its ordeal.\n\n\"Go on now,\" she whispered. \"Your family is waiting for you.\"\n\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"ld help it recover from its ordeal.\n\n\"Go on now,\" she whispered. \"Your family is waiting for you.\"\n\nAs the cub scampered away, Lumi felt the familiar warmth of satisfaction that came from helping another creature. This was her purpose, she realized - not the grand magic of the upper fairies, but the quiet, healing magic of compassion and care.\n\nFrom that day forward, Lumi became known throughout the Whispering Woods as the \"Healer of Lost Things.\" Animals would seek her out when they were hurt or lost, and she would tend to them with the same gentle care she gave to her plants.\n\nYears passed, and Lumi's reputation grew beyond the woods. Travelers who had lost their way would find themselves guided by a soft, golden light that led them safely home. Children who had scraped their knees would wake to find them mysteriously healed, with only a faint scent of wildflowers lingering in the air.\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"wake to find them mysteriously healed, with only a faint scent of wildflowers lingering in the air.\n\nAnd though she remained small and unassuming, Lumi discovered that the greatest magic wasn't in grand gestures or powerful spells, but in the simple acts of kindness that rippled outward, touching lives in ways she could never have imagined.\n\nIn the Whispering Woods, where the ancient oaks still stand and the morning mist still dances, Lumi continues her quiet work, proving that even the smallest fairy can make the biggest difference in the world.\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"},{"code":"t like dragonfly wings, shimmered with the colors of autumn leaves - amber, gold, and deep russet.\n\nEvery dawn, Lumi would emerge from her hollow to tend to her garden of wildflowers and herbs. She had a special gift for healing plants that others had given up on, coaxing life back into withered stems with her gentle touch and whispered incantations.\n\nOne crisp autumn morning, as Lumi was gathering dew from spider webs (her secret ingredient for the most potent healing potions), she heard a soft whimpering coming from deeper in the woods. Following the sound, she discovered a young fox cub caught in a tangle of thorns, its fur matted and its eyes filled with fear.\n\n\"Oh, you poor thing,\" Lumi cooed, hovering just above the cub. \"Don't worry, I'll help you.\"\n\n","file":"commands/gcommit/src/story2.txt","language":"cpp","type":"insertion"}],"cluster_id":1,"commit_message":"Add a story about a fairy named Lumi in the Whispering Woods"},{"affected_files":["commands/gcommit/src/test_impl.py"],"changes":[{"code":"import randomimport mathimport stringimport datetimefrom typing import List, Dict, Anydef shuffle_list(data: List[Any]) -> List[Any]:\n    shuffled = data.copy()\n    random.shuffle(shuffled)\n    return shuffleddef random_sample(data: List[Any], size: int) -> List[Any]:\n    return random.sample(data, min(size, len(data)))def random_choice_weighted(choices: List[Any], weights: List[float]) -> Any:\n    return random.choices(choices, weights=weights)[0]def generate_random_string(length: int, include_symbols: bool = False) -> str:\n    chars = string.ascii_letters + string.digits\n    if include_symbols:\n        chars += \"!@#$%^&*()_+-=[]{}|;:,.<>?\"\n    return ''.join(random.choice(chars) for _ in range(length))def random_dict_subset(data: Dict[Any, Any], size: int) -> Dict[Any, Any]:\n    keys = random.sample(list(data.keys()), min(size, len(data)))\n    return {key: data[key] for key in keys}def random_normal_distribution(mean: float, std_dev: float, count: int) -> List[float]:\n    return [random.gauss(mean, std_dev) for _ in range(count)]def random_exponential_distribution(rate: float, count: int) -> List[float]:\n    return [random.expovariate(rate) for _ in range(count)]def monte_carlo_pi(iterations: int) -> float:\n    inside_circle = 0\n    for _ in range(iterations):\n        x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n        if x*x + y*y <= 1:\n            inside_circle += 1\n    return 4 * inside_circle / iterations","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def random_walk(steps: int, step_size: float = 1.0) -> List[float]:\n    position = 0\n    walk = [position]\n    for _ in range(steps):\n        step = random.choice([-step_size, step_size])\n        position += step\n        walk.append(position)\n    return walkdef random_matrix(rows: int, cols: int, min_val: float = 0, max_val: float = 1) -> List[List[float]]:\n    return [[random.uniform(min_val, max_val) for _ in range(cols)] for _ in range(rows)]def random_date_range(start_date: datetime.date, end_date: datetime.date) -> datetime.date:\n    time_between = end_date - start_date\n    days_between = time_between.days\n    random_days = random.randrange(days_between)\n    return start_date + datetime.timedelta(days=random_days)def random_color_rgb() -> tuple:\n    return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))def random_permutation(n: int) -> List[int]:\n    return random.sample(range(n), n)def random_boolean_probability(probability: float) -> bool:\n    return random.random() < probabilityif __name__ == \"__main__\":\n    test_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(\"Original list:\", test_list)\n    print(\"Shuffled:\", shuffle_list(test_list))\n    print(\"Random sample (3):\", random_sample(test_list, 3))\n    print(\"Pi estimate (10000 iterations):\", monte_carlo_pi(10000))\n    print(\"Random walk (10 steps):\", random_walk(10))\n    print(\"Random RGB color:\", random_color_rgb())\n    print(\"Random string:\", generate_random_string(10, True))","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"}],"cluster_id":2,"commit_message":"Add functions for generating random walks, matrices, date ranges, colors, permutations, and boolean values based on probability."},{"affected_files":["commands/gcommit/src/test_impl.py"],"changes":[{"code":"def fibonacci_sequence(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fibdef prime_numbers_up_to(n: int) -> List[int]:\n    if n < 2:\n        return []\n    \n    primes = []\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primesdef factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)def gcd(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return adef lcm(a: int, b: int) -> int:\n    return abs(a * b) // gcd(a, b)def binary_search(arr: List[int], target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def bubble_sort(arr: List[int]) -> List[int]:\n    arr_copy = arr.copy()\n    n = len(arr_copy)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr_copy[j] > arr_copy[j + 1]:\n                arr_copy[j], arr_copy[j + 1] = arr_copy[j + 1], arr_copy[j]\n    return arr_copydef quick_sort(arr: List[int]) -> List[int]:\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)def merge_sort(arr: List[int]) -> List[int]:\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)def merge(left: List[int], right: List[int]) -> List[int]:\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return resultdef is_palindrome(s: str) -> bool:\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]def reverse_string(s: str) -> str:\n    return s[::-1]def count_vowels(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def remove_duplicates(arr: List[int]) -> List[int]:\n    return list(set(arr))def find_max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    current_sum = arr[0]\n    \n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sumdef two_sum(arr: List[int], target: int) -> List[int]:\n    num_map = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []def is_anagram(s1: str, s2: str) -> bool:\n    return sorted(s1.lower()) == sorted(s2.lower())def longest_common_subsequence(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]def knapsack_01(weights: List[int], values: List[int], capacity: int) -> int:\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def minimum_spanning_tree_kruskal(edges: List[tuple], num_vertices: int) -> List[tuple]:\n    def find(parent, i):\n        if parent[i] != i:\n            parent[i] = find(parent, parent[i])\n        return parent[i]\n    \n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        \n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    \n    edges.sort(key=lambda x: x[2])  # Sort by weight\n    parent = list(range(num_vertices))\n    rank = [0] * num_vertices\n    mst = []\n    \n    for u, v, weight in edges:\n        if find(parent, u) != find(parent, v):\n            mst.append((u, v, weight))\n            union(parent, rank, u, v)\n    \n    return mstdef longest_increasing_subsequence(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    dp = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def dijkstra_shortest_path(graph: dict, start: str, end: str) -> int:\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    visited = set()\n    \n    while len(visited) < len(graph):\n        current = min((node for node in graph if node not in visited), \n                    key=lambda x: distances[x])\n        visited.add(current)\n        \n        for neighbor, weight in graph[current].items():\n            if neighbor not in visited:\n                new_distance = distances[current] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n    \n    return distances[end] if distances[end] != float('infinity') else -1def depth_first_search(graph: dict, start: str, visited: set = None) -> List[str]:\n    if visited is None:\n        visited = set()\n    \n    visited.add(start)\n    result = [start]\n    \n    for neighbor in graph.get(start, []):\n        if neighbor not in visited:\n            result.extend(depth_first_search(graph, neighbor, visited))\n    \n    return resultdef breadth_first_search(graph: dict, start: str) -> List[str]:\n    visited = set()\n    queue = [start]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            queue.extend(graph.get(node, []))\n    \n    return result","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def topological_sort(graph: dict) -> List[str]:\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] = in_degree.get(neighbor, 0) + 1\n    \n    queue = [node for node in in_degree if in_degree[node] == 0]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        \n        for neighbor in graph.get(node, []):\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return resultdef detect_cycle_directed(graph: dict) -> bool:\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {node: WHITE for node in graph}\n    \n    def dfs(node):\n        color[node] = GRAY\n        for neighbor in graph.get(node, []):\n            if color[neighbor] == GRAY:\n                return True\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n        color[node] = BLACK\n        return False\n    \n    for node in graph:\n        if color[node] == WHITE:\n            if dfs(node):\n                return True\n    return False","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def edit_distance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]def coin_change(coins: List[int], amount: int) -> int:\n    dp = [float('infinity')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('infinity') else -1def house_robber(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev2 = nums[0]\n    prev1 = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        current = max(prev1, prev2 + nums[i])\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1def climbing_stairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def subsets(nums: List[int]) -> List[List[int]]:\n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    result = []\n    backtrack(0, [])\n    return resultdef n_queens(n: int) -> List[List[str]]:\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == abs(i - row):\n                return False\n        return True\n    \n    def backtrack(row, board):\n        if row == n:\n            result.append(['.' * col + 'Q' + '.' * (n - col - 1) for col in board])\n            return\n        \n        for col in range(n):\n            if is_safe(board, row, col):\n                board.append(col)\n                backtrack(row + 1, board)\n                board.pop()\n    \n    result = []\n    backtrack(0, [])\n    return resultdef sudoku_solver(board: List[List[str]]) -> bool:\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        \n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == num:\n                    return False\n        return True","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def unique_paths(m: int, n: int) -> int:\n    dp = [[1] * n for _ in range(m)]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]def word_break(s: str, word_dict: List[str]) -> bool:\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    \n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[len(s)]def generate_parentheses(n: int) -> List[str]:\n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        if open_count < n:\n            backtrack(current + \"(\", open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(current + \")\", open_count, close_count + 1)\n    \n    result = []\n    backtrack(\"\", 0, 0)\n    return result","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"},{"code":"def letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    \n    digit_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    def backtrack(index, current):\n        if index == len(digits):\n            result.append(current)\n            return\n        \n        for letter in digit_map[digits[index]]:\n            backtrack(index + 1, current + letter)\n    \n    result = []\n    backtrack(0, \"\")\n    return resultdef combination_sum(candidates: List[int], target: int) -> List[List[int]]:\n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining:\n                current.append(candidates[i])\n                backtrack(i, current, remaining - candidates[i])\n                current.pop()\n    \n    result = []\n    backtrack(0, [], target)\n    return resultdef permutations(nums: List[int]) -> List[List[int]]:\n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for num in nums:\n            if num not in current:\n                current.append(num)\n                backtrack(current)\n                current.pop()\n    \n    result = []\n    backtrack([])\n    return result","file":"commands/gcommit/src/test_impl.py","language":"python","type":"insertion"}],"cluster_id":3,"commit_message":"Add various algorithms implementations: Fibonacci sequence, prime numbers up to a given number, factorial, GCD, LCM, binary search, bubble sort, quick sort, merge sort, palindrome check, reverse string, count vowels, remove duplicates, find max"}]
diff --git a/commands/mcommit/CMakeLists.txt b/commands/mcommit/CMakeLists.txt
index 7ea2f85..5279f38 100644
--- a/commands/mcommit/CMakeLists.txt
+++ b/commands/mcommit/CMakeLists.txt
@@ -32,6 +32,8 @@ find_package(OpenSSL REQUIRED)
 add_library(mcommit_shared STATIC
     ../../shared/https_api.cpp
     ../../shared/openai_api.cpp
+    ../../shared/async_https_api.cpp
+    ../../shared/async_openai_api.cpp
     ../../shared/utils.cpp
 )
 
diff --git a/commands/mcommit/src/main.cpp b/commands/mcommit/src/main.cpp
index 0200c96..975ec64 100644
--- a/commands/mcommit/src/main.cpp
+++ b/commands/mcommit/src/main.cpp
@@ -1,30 +1,36 @@
-#include "openai_api.hpp"
+#include "async_openai_api.hpp"
 #include "utils.hpp"
 using namespace std;
 
 int main() {
-    string api_key = getenv("OPENAI_API_KEY");
+    const char* api_key_env = getenv("OPENAI_API_KEY");
+    string api_key = api_key_env ? api_key_env : "";
 
     if (api_key.empty()) {
-        cerr << "Error: OPENAI_API_KEY not found in .env file or environment variables" << endl;
+        cerr << "Error: OPENAI_API_KEY not found in environment variables" << endl;
         return 1;
-    } 
-
-    OpenAI_ChatAPI openai_chat_api(api_key);
+    }
 
     string diff;
-
     string line;
     while (getline(cin, line)) {
-        if (line[0] == '+') {
+        if (!line.empty() && line[0] == '+') {
             diff += "Insertion: ";
         }
-        else if (line[0] == '-') {
+        else if (!line.empty() && line[0] == '-') {
             diff += "Deletion: ";
         }
         diff += line + "\n";
     }
 
-    string message = generate_commit_message(openai_chat_api, diff);
-    cout << message;
+    AsyncHTTPSConnection conn;
+    AsyncOpenAIAPI openai_api(conn, api_key);
+
+    future<string> msg_future = async_generate_commit_message(openai_api, diff);
+    openai_api.run_requests();
+
+    string message = msg_future.get();
+    cout << message << endl;
+
+    return 0;
 }
\ No newline at end of file
diff --git a/shared/utils.cpp b/shared/utils.cpp
index 14d7946..648cfcc 100644
--- a/shared/utils.cpp
+++ b/shared/utils.cpp
@@ -41,4 +41,42 @@ string generate_commit_message(OpenAIAPI& chat_api, const string& code_changes)
 
     return chat_api.post_chat(messages, 50, 0.3);
     */
+}
+
+string parse_chat_response(const string& response) {
+    try {
+        json j = json::parse(response);
+        string message = j["choices"][0]["message"]["content"].get<string>();
+
+        // Trim whitespace and remove quotes if present
+        size_t start = message.find_first_not_of(" \t\n\r\"");
+        size_t end = message.find_last_not_of(" \t\n\r\"");
+
+        if (start == string::npos) return "update code";
+
+        return message.substr(start, end - start + 1);
+    } catch (json::exception& e) {
+        cout << "Chat JSON parsing error with response: " << response << endl;
+        return "update code"; // fallback message
+    }
+}
+
+future<string> async_generate_commit_message(AsyncOpenAIAPI& chat_api, const string& code_changes) {
+    json messages = {
+        {
+            {"role", "system"},
+            {"content", "You are a git commit message generator. Analyze the code changes and generate a concise commit message that describes what was actually modified, added, or fixed in the code. Focus on the technical changes, not meta-commentary. Return only the commit message without quotes or explanations. Examples: 'add HTTP chunked encoding support', 'handle SSL connection errors', 'extract JSON parsing logic'."}
+        },
+        {
+            {"role", "user"},
+            {"content", "Generate a commit message for these code changes:\n" + code_changes}
+        }
+    };
+
+    future<HTTPSResponse> response_future = chat_api.async_chat(messages, 50, 0.3);
+
+    return std::async(std::launch::deferred, [](future<HTTPSResponse> resp_fut) {
+        HTTPSResponse response = resp_fut.get();
+        return parse_chat_response(response.body);
+    }, std::move(response_future));
 }
\ No newline at end of file
diff --git a/shared/utils.hpp b/shared/utils.hpp
index 104e7e5..78bb4f7 100644
--- a/shared/utils.hpp
+++ b/shared/utils.hpp
@@ -3,11 +3,15 @@
 
 #include <vector>
 #include <string>
+#include <future>
 #include <nlohmann/json.hpp>
 #include "openai_api.hpp"
+#include "async_openai_api.hpp"
 using namespace std;
 
 float cos_sim(vector<float> a, vector<float> b);
 string generate_commit_message(OpenAIAPI& chat_api, const string& code_changes);
+future<string> async_generate_commit_message(AsyncOpenAIAPI& chat_api, const string& code_changes);
+string parse_chat_response(const string& response);
 vector<float> parse_embedding(const string& response);
 #endif // UTILS_HPP
\ No newline at end of file
