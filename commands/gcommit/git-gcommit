#!/bin/bash

# Smart AI Commit Tool
# Stages changes, clusters them, generates commit messages, and creates commits

set -e  # Exit on any error

# Default settings
DISTANCE_THRESHOLD=0.5
VERBOSE=false
STASH_CREATED=false
ORIGINAL_BRANCH=""
STAGING_BRANCH=""

# Cleanup function - restores stash even on error
cleanup() {
  local exit_code=$?

  # Return to original branch if we switched
  if [ -n "$ORIGINAL_BRANCH" ] && [ -n "$STAGING_BRANCH" ]; then
    if git rev-parse --verify "$STAGING_BRANCH" > /dev/null 2>&1; then
      git checkout "$ORIGINAL_BRANCH" 2>/dev/null || true
    fi
  fi

  # Pop the stash if we created one
  if [ "$STASH_CREATED" = true ]; then
    echo "Restoring stashed changes..."
    git stash pop --quiet 2>/dev/null || git stash pop || true
  fi

  # Clean up temp files
  rm -f /tmp/git_gcommit_cluster_*.patch

  exit $exit_code
}

# Set trap to ensure cleanup runs on exit (success, error, or interrupt)
trap cleanup EXIT INT TERM

# Parse command line arguments
while [ $# -gt 0 ]; do
  case "$1" in
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    *)
      DISTANCE_THRESHOLD=$1
      shift
      ;;
  esac
done

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Try to find the executable in multiple locations
EXECUTABLE=""
if [ -f "$SCRIPT_DIR/build/git_gcommit.o" ]; then
  EXECUTABLE="$SCRIPT_DIR/build/git_gcommit.o"
elif [ -f "$(dirname "$0")/git_gcommit.o" ]; then
  EXECUTABLE="$(dirname "$0")/git_gcommit.o"
elif [ -f "$HOME/bin/git_gcommit.o" ]; then
  EXECUTABLE="$HOME/bin/git_gcommit.o"
fi

# Check if executable exists
if [ -z "$EXECUTABLE" ] || [ ! -f "$EXECUTABLE" ]; then
  echo "Error: git_gcommit.o not found. Please build the project first:"
  echo "Run: ./scripts/setup.sh"
  exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: Not in a git repository"
  exit 1
fi

# Check if jq is available for JSON parsing
if ! command -v jq &> /dev/null; then
  echo "Error: jq is required for JSON parsing. Please install jq:"
  echo "brew install jq"
  exit 1
fi

# Check if there are staged changes
if git diff --cached --quiet; then
  echo "No staged changes to commit."
  exit 0
fi

echo "Analyzing staged changes..."

# Save the cached diff BEFORE stashing (stash will clear it)
CACHED_DIFF=$(git diff --cached)

if [ "$VERBOSE" = true ]; then
  echo "Distance threshold: $DISTANCE_THRESHOLD"
  echo "Executable: $EXECUTABLE"
  echo "Git diff preview:"
  echo "$CACHED_DIFF" | head -20
  echo "---"
fi

# Clean up previous patches
rm -rf /tmp/patches

# Generate patches by piping cached diff to the clustering tool
if [ "$VERBOSE" = true ]; then
  echo "$CACHED_DIFF" | "$EXECUTABLE" "$DISTANCE_THRESHOLD"
else
  echo "$CACHED_DIFF" | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>/dev/null
fi

COMMITS_JSON="/tmp/patches/commits.json"

# Check if commits.json was created
if [ ! -f "$COMMITS_JSON" ]; then
  echo "Error: AI commit message generation failed (commits.json not created)"
  exit 1
fi

JSON_OUTPUT=$(cat "$COMMITS_JSON")

if [ "$VERBOSE" = true ]; then
  echo "Commits JSON:"
  echo "$JSON_OUTPUT" | jq .
  echo "---"
fi

# Check if we got valid JSON
if ! echo "$JSON_OUTPUT" | jq empty 2>/dev/null; then
  echo "Warning: Invalid JSON in commits.json, using fallback"
  git commit -m "update code"
  echo "Created fallback commit"
  exit 0
fi

# Parse JSON output and create commits
echo "Generating commits..."

# Get number of clusters
CLUSTER_COUNT=$(echo "$JSON_OUTPUT" | jq length)

if [ "$CLUSTER_COUNT" -eq 0 ]; then
  echo "No clusters generated. Creating single commit..."
  COMMIT_MSG="update code"
  git commit -m "$COMMIT_MSG"
  echo "Created commit: $COMMIT_MSG"
  exit 0
fi

echo "Found $CLUSTER_COUNT clusters"

if [ "$VERBOSE" = true ]; then
  echo "Full cluster details:"
  echo "$JSON_OUTPUT" | jq .
fi

# Save current branch name
ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Create a unique staging branch name
STAGING_BRANCH="gcommit-staging-$(date +%s)"

# Stash ALL changes (staged + unstaged) to get a clean working tree
# --keep-index is NOT used because we want to stash staged changes too
echo "Stashing all changes..."
if git stash push -m "gcommit: auto-stash before staging branch" --include-untracked; then
  STASH_CREATED=true
else
  # If stash fails (nothing to stash), that's okay - continue
  STASH_CREATED=false
fi

# Create and switch to staging branch
echo "Creating staging branch: $STAGING_BRANCH"
git checkout -b "$STAGING_BRANCH"

# For each cluster, apply its patch and create a commit
for i in $(seq 0 $((CLUSTER_COUNT - 1))); do
  COMMIT_MESSAGE=$(echo "$JSON_OUTPUT" | jq -r ".[$i].commit_message")
  PATCH_FILE="/tmp/patches/cluster_$i.patch"

  if [ "$VERBOSE" = true ]; then
    echo "Processing cluster $((i + 1))..."
    echo "Commit message: $COMMIT_MESSAGE"
    echo "Patch file: $PATCH_FILE"
  fi

  echo "Cluster $((i + 1)): $COMMIT_MESSAGE"

  # Check if patch file exists
  if [ ! -f "$PATCH_FILE" ]; then
    echo "Warning: Patch file $PATCH_FILE not found, skipping cluster $((i + 1))"
    continue
  fi

  # Apply the patch
  if [ "$VERBOSE" = true ]; then
    echo "Applying patch..."
    cat "$PATCH_FILE"
  fi

  if git apply --check "$PATCH_FILE" 2>/dev/null; then
    git apply "$PATCH_FILE"
    git add -A
    git commit -m "$COMMIT_MESSAGE"
    echo "Created commit: $COMMIT_MESSAGE"
  else
    echo "Warning: Could not apply patch for cluster $((i + 1)), skipping"
    if [ "$VERBOSE" = true ]; then
      git apply --check "$PATCH_FILE" 2>&1 || true
    fi
  fi
done

# Merge staging branch back to original branch
echo "Merging commits back to $ORIGINAL_BRANCH..."
git checkout "$ORIGINAL_BRANCH"
git merge "$STAGING_BRANCH" --no-edit

# Delete the staging branch
git branch -d "$STAGING_BRANCH"
STAGING_BRANCH=""  # Clear so cleanup doesn't try to switch again

echo "Smart commit complete!"