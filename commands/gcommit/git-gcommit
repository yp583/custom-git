#!/bin/bash

# Smart AI Commit Tool
# Stages changes, clusters them, generates commit messages, and creates commits

set -e  # Exit on any error

# Default settings
DISTANCE_THRESHOLD=0.5
VERBOSE=false

# Parse command line arguments
while [ $# -gt 0 ]; do
  case "$1" in
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    *)
      DISTANCE_THRESHOLD=$1
      shift
      ;;
  esac
done

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Try to find the executable in multiple locations
EXECUTABLE=""
if [ -f "$SCRIPT_DIR/build/git_gcommit.o" ]; then
  EXECUTABLE="$SCRIPT_DIR/build/git_gcommit.o"
elif [ -f "$(dirname "$0")/git_gcommit.o" ]; then
  EXECUTABLE="$(dirname "$0")/git_gcommit.o"
elif [ -f "$HOME/bin/git_gcommit.o" ]; then
  EXECUTABLE="$HOME/bin/git_gcommit.o"
fi

# Check if executable exists
if [ -z "$EXECUTABLE" ] || [ ! -f "$EXECUTABLE" ]; then
  echo "Error: git_gcommit.o not found. Please build the project first:"
  echo "Run: ./scripts/setup.sh"
  exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: Not in a git repository"
  exit 1
fi

# Check if jq is available for JSON parsing
if ! command -v jq &> /dev/null; then
  echo "Error: jq is required for JSON parsing. Please install jq:"
  echo "brew install jq"
  exit 1
fi

# Check if there are staged changes
if git diff --cached --quiet; then
  echo "No staged changes to commit."
  exit 0
fi

echo "Analyzing staged changes..."

if [ "$VERBOSE" = true ]; then
  echo "Distance threshold: $DISTANCE_THRESHOLD"
  echo "Executable: $EXECUTABLE"
  echo "Git diff preview:"
  git diff --cached | head -20
  echo "---"
fi

# Generate git diff for staged changes and pipe to the clustering tool
if [ "$VERBOSE" = true ]; then
  # In verbose mode, show stderr output
  JSON_OUTPUT=$(git diff --cached | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>&1 | tee /dev/stderr)
else
  # In normal mode, capture stderr but don't show it
  JSON_OUTPUT=$(git diff --cached | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>&1)
fi

if [ "$VERBOSE" = true ]; then
  echo "Raw output from executable:"
  echo "$JSON_OUTPUT"
  echo "---"
fi

# Extract just the JSON part (last line that starts with [)
JSON_ONLY=$(echo "$JSON_OUTPUT" | grep '^\[' | tail -1)

if [ "$VERBOSE" = true ]; then
  echo "Extracted JSON:"
  echo "$JSON_ONLY"
  echo "---"
fi

# Check if we got valid JSON
if [ -z "$JSON_ONLY" ] || ! echo "$JSON_ONLY" | jq empty 2>/dev/null; then
  if [ "$VERBOSE" = true ]; then
    echo "JSON validation failed"
if ! echo "$JSON_OUTPUT" | jq empty 2>/dev/null; then
  echo "Warning: Invalid JSON in commits.json, using fallback"
  git commit -m "update code"
  echo "Created fallback commit"
  exit 0
fi

# Parse JSON output and create commits
echo "Generating commits..."

# Get number of clusters
CLUSTER_COUNT=$(echo "$JSON_OUTPUT" | jq length)

if [ "$CLUSTER_COUNT" -eq 0 ]; then
  echo "No clusters generated. Creating single commit..."
  COMMIT_MSG="update code"
  git commit -m "$COMMIT_MSG"
  echo "Created commit: $COMMIT_MSG"
  exit 0
fi

echo "Found $CLUSTER_COUNT clusters"

if [ "$VERBOSE" = true ]; then
  echo "Full cluster details:"
  echo "$JSON_OUTPUT" | jq .
fi

# For each cluster, create a commit
for i in $(seq 0 $((CLUSTER_COUNT - 1))); do
  COMMIT_MESSAGE=$(echo "$JSON_OUTPUT" | jq -r ".[$i].commit_message")

  if [ "$VERBOSE" = true ]; then
    echo "Processing cluster $((i + 1))..."
    echo "Commit message: $COMMIT_MESSAGE"
    echo "Affected files:"
    echo "$JSON_OUTPUT" | jq -r ".[$i].affected_files[]"
  fi

  echo "Cluster $((i + 1)): $COMMIT_MESSAGE"
  
  # Create temp files to stage specific changes for this cluster
  TEMP_PATCH="/tmp/git_gcommit_cluster_$i.patch"
  
  # Extract changes for this cluster and create a patch
  echo "$JSON_OUTPUT" | jq -r ".[$i].changes[] | 
    if .type == \"insertion\" then 
      \"+\" + .code 
    else 
      \"-\" + .code 
    end" > "$TEMP_PATCH"
  
  # For now, we'll commit all staged changes with the first cluster's message
  # In a more sophisticated version, we'd selectively stage changes per cluster
  if [ $i -eq 0 ]; then
    git commit -m "$COMMIT_MESSAGE"
    echo "Created commit: $COMMIT_MESSAGE"
    break
  fi
done

# Clean up temp files
rm -f /tmp/git_gcommit_cluster_*.patch

echo "Smart commit complete!"