#!/bin/bash

# Smart AI Commit Tool
# Stages changes, clusters them, generates commit messages, and creates commits

set -e  # Exit on any error

# Default settings
DISTANCE_THRESHOLD=0.5
VERBOSE=false
STASH_CREATED=false
ORIGINAL_BRANCH=""
STAGING_BRANCH=""

# Cleanup function - restores stash even on error
cleanup() {
  local exit_code=$?

  # Return to original branch if we switched (only on failure - STAGING_BRANCH is cleared on success)
  if [ -n "$ORIGINAL_BRANCH" ] && [ -n "$STAGING_BRANCH" ]; then
    git checkout "$ORIGINAL_BRANCH" 2>/dev/null || true
    # Delete staging branch on failure
    if git rev-parse --verify "$STAGING_BRANCH" > /dev/null 2>&1; then
      git branch -D "$STAGING_BRANCH" 2>/dev/null || true
    fi
  fi

  # Pop the stash if we created one
  # Use --index to preserve staged vs unstaged separation (works because HEAD hasn't moved)
  if [ "$STASH_CREATED" = true ]; then
    echo "Restoring your working tree..."
    if ! git stash pop --index --quiet 2>/dev/null; then
      echo "Warning: Could not restore with --index, trying without..."
      git stash pop --quiet 2>/dev/null || echo "Your changes are in: git stash list"
    fi
  fi

  # Clean up temp files
  rm -f /tmp/git_gcommit_cluster_*.patch

  exit $exit_code
}

# Set trap to ensure cleanup runs on exit (success, error, or interrupt)
trap cleanup EXIT INT TERM

# Parse command line arguments
while [ $# -gt 0 ]; do
  case "$1" in
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    *)
      DISTANCE_THRESHOLD=$1
      shift
      ;;
  esac
done

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Find the executable only in $HOME/bin
EXECUTABLE=""
if [ -f "$HOME/bin/git_gcommit.o" ]; then
  EXECUTABLE="$HOME/bin/git_gcommit.o"
fi

# Check if executable exists
if [ -z "$EXECUTABLE" ] || [ ! -f "$EXECUTABLE" ]; then
  echo "Error: git_gcommit.o not found. Please build the project first:"
  echo "Run: ./scripts/setup.sh"
  exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: Not in a git repository"
  exit 1
fi

# Check if jq is available for JSON parsing
if ! command -v jq &> /dev/null; then
  echo "Error: jq is required for JSON parsing. Please install jq:"
  echo "brew install jq"
  exit 1
fi

# Check if there are staged changes
if git diff --cached --quiet; then
  echo "No staged changes to commit."
  exit 0
fi

echo "Analyzing staged changes..."

# Save the cached diff BEFORE stashing (stash will clear it)
CACHED_DIFF=$(git diff --cached)

if [ "$VERBOSE" = true ]; then
  echo "Distance threshold: $DISTANCE_THRESHOLD"
  echo "Executable: $EXECUTABLE"
  echo "Git diff preview:"
  echo "$CACHED_DIFF" | head -20
  echo "---"
fi

# Clean up previous patches
rm -rf /tmp/patches

# Generate patches by piping cached diff to the clustering tool
if [ "$VERBOSE" = true ]; then
  echo "$CACHED_DIFF" | "$EXECUTABLE" "$DISTANCE_THRESHOLD"
else
  echo "$CACHED_DIFF" | "$EXECUTABLE" "$DISTANCE_THRESHOLD" 2>/dev/null
fi

COMMITS_JSON="/tmp/patches/commits.json"

# Check if commits.json was created
if [ ! -f "$COMMITS_JSON" ]; then
  echo "Error: AI commit message generation failed (commits.json not created)"
  exit 1
fi

JSON_OUTPUT=$(cat "$COMMITS_JSON")

if [ "$VERBOSE" = true ]; then
  echo "Commits JSON:"
  echo "$JSON_OUTPUT" | jq .
  echo "---"
fi

# Check if we got valid JSON
if ! echo "$JSON_OUTPUT" | jq empty 2>/dev/null; then
  echo "Warning: Invalid JSON in commits.json, using fallback"
  git commit -m "update code"
  echo "Created fallback commit"
  exit 0
fi

# Parse JSON output and create commits
echo "Generating commits..."

# Get number of clusters
CLUSTER_COUNT=$(echo "$JSON_OUTPUT" | jq length)

if [ "$CLUSTER_COUNT" -eq 0 ]; then
  echo "No clusters generated. Creating single commit..."
  COMMIT_MSG="update code"
  git commit -m "$COMMIT_MSG"
  echo "Created commit: $COMMIT_MSG"
  exit 0
fi

echo "Found $CLUSTER_COUNT clusters"

if [ "$VERBOSE" = true ]; then
  echo "Full cluster details:"
  echo "$JSON_OUTPUT" | jq .
fi

# Save current branch name
ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Create a unique staging branch name
STAGING_BRANCH="gcommit-staging-$(date +%s)"

# Stash ALL changes (staged + unstaged) to get a clean working tree
echo "Stashing all changes..."
STASH_COUNT_BEFORE=$(git stash list | wc -l | tr -d ' ')
git stash push -m "gcommit: auto-stash before staging branch" --include-untracked || true
STASH_COUNT_AFTER=$(git stash list | wc -l | tr -d ' ')

if [ "$STASH_COUNT_AFTER" -gt "$STASH_COUNT_BEFORE" ]; then
  STASH_CREATED=true
else
  # Nothing was actually stashed
  STASH_CREATED=false
fi

# Create and switch to staging branch
echo "Creating staging branch: $STAGING_BRANCH"
git checkout -b "$STAGING_BRANCH"

# For each cluster, apply its patches and create a commit
for i in $(seq 0 $((CLUSTER_COUNT - 1))); do
  COMMIT_MESSAGE=$(echo "$JSON_OUTPUT" | jq -r ".[$i].commit_message")

  # Get patch_paths array for this cluster
  PATCH_PATHS=$(echo "$JSON_OUTPUT" | jq -r ".[$i].patch_paths[]")

  if [ "$VERBOSE" = true ]; then
    echo "Processing cluster $((i + 1))..."
    echo "Commit message: $COMMIT_MESSAGE"
    echo "Patch paths: $PATCH_PATHS"
  fi

  echo "Cluster $((i + 1)): $COMMIT_MESSAGE"

  # Apply each patch in this cluster
  for PATCH_FILE in $PATCH_PATHS; do
    # Check if patch file exists
    if [ ! -f "$PATCH_FILE" ]; then
      echo "Error: Patch file $PATCH_FILE not found"
      exit 1
    fi

    # Apply the patch
    if [ "$VERBOSE" = true ]; then
      echo "Applying patch: $PATCH_FILE"
      cat "$PATCH_FILE"
    fi

    if ! git apply --unidiff-zero --check "$PATCH_FILE" 2>/dev/null; then
      echo "Error: Could not apply patch $PATCH_FILE"
      if [ "$VERBOSE" = true ]; then
        git apply --unidiff-zero --check "$PATCH_FILE" 2>&1 || true
      fi
      exit 1
    fi

    git apply --unidiff-zero "$PATCH_FILE"
  done

  # Stage and commit all patches for this cluster
  git add -A
  git commit -m "$COMMIT_MESSAGE"
  echo "Created commit: $COMMIT_MESSAGE"
done

# Switch back to original branch (don't merge yet)
git checkout "$ORIGINAL_BRANCH"

# Clear STAGING_BRANCH so cleanup doesn't delete it
STAGING_BRANCH_NAME="$STAGING_BRANCH"
STAGING_BRANCH=""

# Show summary of commits created on staging branch
echo ""
echo "=== Commits ready on staging branch: $STAGING_BRANCH_NAME ==="
git log --oneline "$ORIGINAL_BRANCH".."$STAGING_BRANCH_NAME"
echo ""
echo "To merge: git merge $STAGING_BRANCH_NAME"
echo "To review: git log -p $ORIGINAL_BRANCH..$STAGING_BRANCH_NAME"
echo "To delete: git branch -D $STAGING_BRANCH_NAME"
echo "============================================================="