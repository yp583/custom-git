Parsed 10 files from git diff
Starting hierarchical clustering with distance threshold of 0.5 ...
Clustering complete. Found 2 clusters
Chunk 76465836:
In the year 2047, Margaret discovered she could communicate with ancient trees through quantum entanglement. The towering redwoods whispered secrets of civilizations long forgotten, their roots extending through dimensions unknown to humanity. As she placed her palm against the bark of the oldest sequoia in California's Muir Woods, Margaret felt the pulse of the universe itself coursing through her veins.

The trees revealed that Earth was not the first planet they had inhabited. They had traveled across galaxies as spores carried by stellar winds, seeding life wherever they found suitable conditions. Margaret learned that these ancient beings had witnessed the birth and death of countless stars, had seen black holes devour entire solar systems, and had survived cosmic catastrophes that would have obliterated any other form of life.


The trees revealed that Earth was not the first planet they had inhabited. They had traveled across galaxies as spores carried by stellar winds, seeding life wherever they found suitable conditions. Margaret learned that these ancient beings had witnessed the birth and death of countless stars, had seen black holes devour entire solar systems, and had survived cosmic catastrophes that would have obliterated any other form of life.

Through their connection, Margaret discovered that humanity was not alone in the universe. The trees had been in contact with other civilizations for millennia, serving as intergalactic communication relays. They showed her visions of crystalline cities floating in the atmospheres of gas giants, of underwater civilizations that had mastered fusion energy, and of beings made entirely of pure energy who existed in the spaces between atoms.


Through their connection, Margaret discovered that humanity was not alone in the universe. The trees had been in contact with other civilizations for millennia, serving as intergalactic communication relays. They showed her visions of crystalline cities floating in the atmospheres of gas giants, of underwater civilizations that had mastered fusion energy, and of beings made entirely of pure energy who existed in the spaces between atoms.

But with this knowledge came a terrible responsibility. The trees warned Margaret that Earth was approaching a critical juncture. The planet's magnetic field was weakening, and cosmic radiation was increasing. Within fifty years, unless humanity could find a way to strengthen the planet's protective barriers, all life on Earth would face extinction.


But with this knowledge came a terrible responsibility. The trees warned Margaret that Earth was approaching a critical juncture. The planet's magnetic field was weakening, and cosmic radiation was increasing. Within fifty years, unless humanity could find a way to strengthen the planet's protective barriers, all life on Earth would face extinction.

Margaret realized she had been chosen not just to receive this knowledge, but to act upon it. The trees had been preparing for this moment for centuries, slowly guiding human technological development toward the solutions needed to save their world. They showed her blueprints for devices that could harness the power of Earth's core to generate protective magnetic fields, and revealed the locations of rare minerals needed to construct them.


Margaret realized she had been chosen not just to receive this knowledge, but to act upon it. The trees had been preparing for this moment for centuries, slowly guiding human technological development toward the solutions needed to save their world. They showed her blueprints for devices that could harness the power of Earth's core to generate protective magnetic fields, and revealed the locations of rare minerals needed to construct them.

As Margaret began her quest to save humanity, she discovered that she was not the only one who had been contacted. Around the world, others were receiving similar messages from different species - whales who spoke of ancient ocean currents that could power entire cities, birds who revealed the secrets of atmospheric manipulation, and even insects who shared knowledge of molecular engineering that could revolutionize medicine.


As Margaret began her quest to save humanity, she discovered that she was not the only one who had been contacted. Around the world, others were receiving similar messages from different species - whales who spoke of ancient ocean currents that could power entire cities, birds who revealed the secrets of atmospheric manipulation, and even insects who shared knowledge of molecular engineering that could revolutionize medicine.

Together, this unlikely alliance of humans and Earth's other inhabitants worked to implement the trees' plans. They built massive facilities deep underground, where the planet's geothermal energy could be harnessed. They developed new technologies that could manipulate Earth's magnetic field, creating a protective shield that would last for millennia.


Together, this unlikely alliance of humans and Earth's other inhabitants worked to implement the trees' plans. They built massive facilities deep underground, where the planet's geothermal energy could be harnessed. They developed new technologies that could manipulate Earth's magnetic field, creating a protective shield that would last for millennia.

The project was not without its challenges. Some governments tried to weaponize the technology, while others sought to exploit the newfound knowledge for profit. Margaret and her allies had to navigate political intrigue, corporate espionage, and even attempts on their lives as they worked to save the planet.

In the end, their efforts succeeded. Earth's protective barriers were restored, and humanity entered a new golden age of cooperation with the planet's other inhabitants. The trees continued to serve as bridges between worlds, helping humanity establish peaceful contact with other civilizations across the galaxy.


In the end, their efforts succeeded. Earth's protective barriers were restored, and humanity entered a new golden age of cooperation with the planet's other inhabitants. The trees continued to serve as bridges between worlds, helping humanity establish peaceful contact with other civilizations across the galaxy.

Margaret became known as the Guardian of Earth, but she knew that the real heroes were the ancient trees who had watched over the planet for millions of years, patiently waiting for the right moment to share their wisdom. As she stood beneath the great sequoia that had started it all, she felt a deep sense of gratitude and wonder at the interconnected web of life that had brought them all together.

The story of Margaret and the ancient trees became legend, passed down through generations as a reminder that sometimes the greatest adventures begin with a simple act of listening to the world around us.


Chunk 76465836:
Parsed 9 files from git diff
LANGUGE: text
LANGUGE: cpp
=== INSERTION CHUNK ===
File: commands/gcommit/src/chunker.cpp
Content:
#include "chunker.hpp"
Chunker::Chunker() {
}
Chunker::~Chunker() {
}

=======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: commands/gcommit/src/chunker.hpp
Content:
class Chunker {
private:
public:
    Chunker();
    
    ~Chunker();
};

=======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: commands/gcommit/src/hierarchal.hpp
Content:
private:
  vector<vector<int>> clusters;
public:
  HierachicalClustering();
  void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
  vector<vector<int>> get_clusters();
  ~HierachicalClustering();
};

=======================
=== DELETION CHUNK ===
File: commands/gcommit/src/hierarchal.hpp
Content:
private:
  vector<vector<int>> clusters;
public:
    HierachicalClustering();
    void cluster(vector<vector<float>> data, float distance_threshold = 0.5);

    HierachicalClustering();
    void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
    vector<vector<int>> get_clusters();
    ~HierachicalClustering();
};

======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: commands/gcommit/src/main.cpp
Content:
#include "diffreader.hpp"
#include <regex>
#include <set>
#include <vector>

=======================
=== INSERTION CHUNK ===
File: commands/gcommit/src/main.cpp
Content:
struct Chunk {
  string code;
  vector<float> embedding;
int main(int argc, char *argv[]) {
  // string api_key = getenv("OPENAI_API_KEY");
  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
  // vector<vector<float>> embeddings;
  //handles reading from cin too
  DiffReader dr(cin);
  dr.ingestDiff();
  cout << "Parsed " << dr.getFiles().size() << " files from git diff" << endl;

=======================
=== INSERTION CHUNK ===
File: commands/gcommit/src/main.cpp
Content:
  for (const DiffFile& file : dr.getFiles()) {

Content:
  for (const DiffFile& file : dr.getFiles()) {
    vector<DiffChunk> ins_chunks;
    vector<DiffChunk> del_chunks;

    string language = detectLanguageFromPath(file.filepath);
    DiffChunk file_ins = getDiffContent(file, {EQ, INSERTION});
    DiffChunk file_del = getDiffContent(file, {EQ, DELETION});
    string file_ins_content = combineContent(file_ins);
    string file_del_content = combineContent(file_del);
    if (language != "text") { //use ast for non text files
      ts::Tree ins_tree = codeToTree(file_ins_content, language);
      ts::Tree del_tree = codeToTree(file_del_content, language);
      vector<DiffChunk> ins_chunks = chunkNode(ins_tree.getRootNode(), file_ins);
      vector<DiffChunk> del_chunks = chunkNode(del_tree.getRootNode(), file_del);
    }

    for (const DiffChunk& chunk : ins_chunks) {
      cout << "=== INSERTION CHUNK ===" << endl;
      cout << "File: " << chunk.filepath << endl;
      cout << "Content:" << endl;

  for (const DiffFile& file : dr.getFiles()) {
    vector<DiffChunk> ins_chunks;
    vector<DiffChunk> del_chunks;

    string language = detectLanguageFromPath(file.filepath);
    DiffChunk file_ins = getDiffContent(file, {EQ, INSERTION});
    DiffChunk file_del = getDiffContent(file, {EQ, DELETION});
    string file_ins_content = combineContent(file_ins);
    string file_del_content = combineContent(file_del);
    if (language != "text") { //use ast for non text files
      ts::Tree ins_tree = codeToTree(file_ins_content, language);
      ts::Tree del_tree = codeToTree(file_del_content, language);
      vector<DiffChunk> ins_chunks = chunkNode(ins_tree.getRootNode(), file_ins);
      vector<DiffChunk> del_chunks = chunkNode(del_tree.getRootNode(), file_del);
    }

    for (const DiffChunk& chunk : ins_chunks) {
      cout << "=== INSERTION CHUNK ===" << endl;
      cout << "File: " << chunk.filepath << endl;
      cout << "Content:" << endl;
      cout << combineContent(chunk) << endl;
      cout << "=======================" << endl;
    }
    
    for (const DiffChunk& chunk : del_chunks) {
      cout << "=== DELETION CHUNK ===" << endl;
      cout << "File: " << chunk.filepath << endl;
      cout << "Content:" << endl;
      cout << combineContent(chunk) << endl;
      cout << "======================" << endl;
    }
  }

      cout << "File: " << chunk.filepath << endl;
      cout << "Content:" << endl;
      cout << combineContent(chunk) << endl;
      cout << "=======================" << endl;
    }
    
    for (const DiffChunk& chunk : del_chunks) {
      cout << "=== DELETION CHUNK ===" << endl;
      cout << "File: " << chunk.filepath << endl;
      cout << "Content:" << endl;
      cout << combineContent(chunk) << endl;
      cout << "======================" << endl;
    }
  }

=======================
=== INSERTION CHUNK ===
File: commands/gcommit/src/main.cpp
Content:
  // // Process each file with language-specific parsing
  // vector<Chunk> all_chunks;

=======================
=== DELETION CHUNK ===
File: commands/gcommit/src/main.cpp
Content:
#include "diffreader.hpp"
#include <regex>
#include <set>
struct Chunk {
  string code;
  vector<float> embedding;


int main(int argc, char *argv[]) {
  string line;
  string git_diff;


  // string api_key = getenv("OPENAI_API_KEY");
  

  // string api_key = getenv("OPENAI_API_KEY");
  
  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
  // vector<vector<float>> embeddings;

  DiffReader dr(cin);

  dr.ingestDiff();


  cout << dr.getFiles().size() << endl;

  for (const auto& file : dr.getFiles()) {
    cout << "File: " << file.filepath << endl;
    for (const auto& line : file.lines) {
      string mode_str;
      switch (line.mode) {
        case EQ: mode_str = "EQ"; break;
        case INSERTION: mode_str = "INSERTION"; break;
        case DELETION: mode_str = "DELETION"; break;
      }
      cout << "  [" << mode_str << "] " << line.content << endl;
    }
    cout << endl;
  }
  // // Parse git diff to extract file-specific changes
  // vector<DiffFile> diff_files;
  // DiffFile current_file;
  // bool in_file = false;
  // bool in_chunk = false;
  // regex diff_header_regex("^diff --git a/(.*) b/(.*)");
  // regex chunk_header_regex("^@@.*@@");
  // regex ins_regex("^\\+(?!\\+)(.*)");

  // regex chunk_header_regex("^@@.*@@");
  // regex ins_regex("^\\+(?!\\+)(.*)");
  // regex del_regex("^\\-(?!\\-)(.*)");
  // while (getline(cin, line)) {
  //   smatch match;
  //   // Check for new file header
  //   if (regex_match(line, match, diff_header_regex)) {
  //     // Save previous file if exists
  //     if (in_file) {
  //       diff_files.push_back(current_file);
  //     }

======================
=== DELETION CHUNK ===
File: commands/gcommit/src/main.cpp
Content:
  //     // Start new file
  //     current_file = DiffFile();
  //     current_file.filepath = match[2]; // Use 'b/' path (after changes)
  //     current_file.language = detectLanguageFromPath(current_file.filepath);
  //     in_file = true;
  //     in_chunk = false;
  //     continue;
  //   }
  //   // Check for chunk header (@@)
  //   if (in_file && regex_match(line, chunk_header_regex)) {
  //     in_chunk = true;
  //     continue;
  //   }
  //   // Process diff lines if we're in a chunk

  //   }
  //   // Process diff lines if we're in a chunk
  //   if (in_file && in_chunk) {
  //     if (regex_match(line, match, ins_regex)) {
  //       current_file.insertions += match[1].str() + "\n";
  //     } else if (regex_match(line, match, del_regex)) {
  //       current_file.deletions += match[1].str() + "\n";
  //     }
  //   }
  // }
  // // Don't forget the last file
  // if (in_file) {
  //   diff_files.push_back(current_file);
  // }
  // cerr << "Parsed " << diff_files.size() << " files from git diff" << endl;
  // // Process each file with language-specific parsing
  // vector<Chunk> all_chunks;

======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: shared/ast.cpp
Content:
TSLanguage* tree_sitter_go();
}
// Helper function to calculate the total character size of DiffLines
size_t calculateDiffLinesSize(const vector<DiffLine>& lines) {
  size_t totalSize = 0;
  for (const DiffLine& line : lines) {
      totalSize += line.content.length() + 1;
  }

      totalSize += line.content.length() + 1;
  }
  return totalSize;
}
// Helper function to extract DiffLines that fall within a byte range
vector<DiffLine> extractLinesInRange(const vector<DiffLine>& diffLines, size_t startByte, size_t endByte) {
  vector<DiffLine> result;
  size_t currentByte = 0;
  
  for (const auto& line : diffLines) {
      size_t lineStart = currentByte;
      size_t lineEnd = currentByte + line.content.length() + 1; // +1 for newline
      
      // Check if this line overlaps with the target range
      if (lineStart < endByte && lineEnd > startByte) {
          result.push_back(line);
      }
      
      currentByte = lineEnd;
      
      // Early exit if we've passed the end of the range
      if (currentByte >= endByte) {
          break;
      }
  }
  
  return result;
}

=======================
=== INSERTION CHUNK ===
File: shared/ast.cpp
Content:
vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {


vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {

=======================
=== INSERTION CHUNK ===
File: shared/ast.cpp
Content:
vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
  vector<DiffChunk> newChunks;
  DiffChunk currentChunk;
  currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
  size_t currentChunkSize = 0;

=======================
=== INSERTION CHUNK ===
File: shared/ast.cpp
Content:
  for (size_t i = 0; i < node.getNumChildren(); i++) {
      ts::Node child = node.getChild(i);
      auto byteRange = child.getByteRange();
      
      vector<DiffLine> childLines = extractLinesInRange(diffChunk.lines, byteRange.start, byteRange.end);
      size_t childSize = calculateDiffLinesSize(childLines);

      if (childSize > maxChars) {
          if (!currentChunk.lines.empty()) {
              newChunks.push_back(currentChunk);
              currentChunk = DiffChunk();

              newChunks.push_back(currentChunk);
              currentChunk = DiffChunk();
              currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
              currentChunkSize = 0;
          }
          auto childChunks = chunkNode(child, diffChunk, maxChars);
          newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
      }
      else if (currentChunkSize + childSize > maxChars) {
          newChunks.push_back(currentChunk);
          currentChunk = DiffChunk();
          currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
          currentChunk.lines = childLines;
          currentChunkSize = childSize;
      }
      else {
          currentChunk.lines.insert(currentChunk.lines.end(), childLines.begin(), childLines.end());
          currentChunkSize += childSize;
      }
  }
  if (!currentChunk.lines.empty()) {
      newChunks.push_back(currentChunk);
  }
  return newChunks;
}

=======================


=======================
=== INSERTION CHUNK ===
File: shared/ast.cpp
Content:
ts::Tree codeToTree(const string& code, const string& language) {
    return "typescript";
  } else if (extension == ".go") {
    return "go";
  } else if (extension == ".cpp") {
    return "cpp"; // Default fallback
  } else {
    return "text";
  }
}

=======================
=== DELETION CHUNK ===
File: shared/ast.cpp
Content:
TSLanguage* tree_sitter_go();
}
vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars) {
    vector<string> newChunks;
    string currentChunk;

    for (size_t i = 0; i < node.getNumChildren(); i++) {
        ts::Node child = node.getChild(i);
        auto byteRange = child.getByteRange();
        size_t childLength = byteRange.end - byteRange.start;

        if (childLength > maxChars) {
            if (!currentChunk.empty()) {
                newChunks.push_back(currentChunk);
                currentChunk.clear();
            }

                currentChunk.clear();
            }
            auto childChunks = chunkNode(child, text, maxChars);
            newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
        }
        else if (currentChunk.length() + childLength > maxChars) {
            newChunks.push_back(currentChunk);
            currentChunk = text.substr(byteRange.start, childLength);
        }
        else {
            currentChunk += text.substr(byteRange.start, childLength);
        }
    }

    if (!currentChunk.empty()) {
        newChunks.push_back(currentChunk);
    }

    return newChunks;
}
ts::Tree codeToTree(const string& code, const string& language) {
    return "typescript";
  } else if (extension == ".go") {
    return "go";
  } else {
    return "cpp"; // Default fallback
  }
}
// int main() {
//   string git_diff;
//   string line;
//   while (getline(cin, line))
//   {
//       git_diff += line + "\n";
//   }
//   size_t pos = 0;

======================


======================
=== DELETION CHUNK ===
File: shared/ast.cpp
Content:
//   while ((pos = git_diff.find("-", pos)) != string::npos) {
//       git_diff.replace(pos, 1, "");
//   }
//   string original_diff = git_diff;
//   regex re("(@@).+(@@)");
//   sregex_iterator regex_delim = sregex_iterator(git_diff.begin(), git_diff.end(), re);
//   sregex_iterator end = sregex_iterator();
//   vector<string> git_chunks;
//   for (sregex_iterator it = regex_delim; it != end; it++) {
//       smatch match = *it;
//       git_chunks.push_back(match.suffix());
//   }
//   ts::Tree tree = codeToTree(original_diff);
//   vector<string> chunks = chunkNode(tree.getRootNode(), original_diff);
//   for (int i = 0; i < chunks.size(); i++) {
//     cout << "Chunk " << i << ": " << chunks[i] << endl;
//   }
//   return 0;
// }

======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: shared/ast.hpp
Content:
#ifndef AST_HPP
#define AST_HPP

#include <string>
#include <cassert>

#include <string>
#include <cassert>
#include <cstdio>
#include <vector>
#include <cpp-tree-sitter.h>
#include <vector>
#include "diffreader.hpp"

using namespace std;
// Function declarations
vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars = 1500);
ts::Tree codeToTree(const string& code, const string& language);
string detectLanguageFromPath(const string& filepath);
vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
bool isTextFile(const string& filepath);

#endif // AST_HPP 

=======================
=== DELETION CHUNK ===
File: shared/ast.hpp
Content:
#include <string>
#include <cassert>
#include <cstdio>
#include <vector>
#include <cpp-tree-sitter.h>
#include <vector>
using namespace std;
// Function declarations
vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars = 1500);
ts::Tree codeToTree(const string& code, const string& language);

vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars = 1500);
ts::Tree codeToTree(const string& code, const string& language);
string detectLanguageFromPath(const string& filepath);
vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
bool isTextFile(const string& filepath); 

======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: shared/diffreader.cpp
Content:
#include "diffreader.hpp"
#include <vector>
DiffReader::DiffReader(istream& in, bool verbose) 
    : in(in), 
      verbose(verbose), 
      diff_header_regex(regex("^diff --git a/(.*) b/(.*)")),
      in_file(false), 
      in_chunk(false), 
      curr_line_num(0)
{}
vector<DiffFile> DiffReader::getFiles() const {
    return this->files;
}
        // Start new file
        DiffFile current_file = DiffFile{};
        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
        this->curr_line_num = 0;

        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
        this->curr_line_num = 0;
        this->in_file = true;
        this->in_chunk = false;
        return;
    }
    // Check for chunk header (@@). This will skip some context for the diff (one line per chunk header). TODO: fix

=======================
=== INSERTION CHUNK ===
File: shared/diffreader.cpp
Content:
    if (this->in_file && line.substr(0, 2) == "@@") {
        this->in_chunk = true;
        if (this->verbose){
    // Process diff lines if we're in a chunk
    if (this->in_file && this->in_chunk && !this->files.empty()) {
        DiffLine dline;
        dline.content = line.substr(1);
        dline.line_num = this->curr_line_num;


        if (this->verbose){
            cout << "LINE BEING ADDED: " << line << endl;
        }
        
        
        
        if (line[0] == '+') {
            dline.mode = INSERTION;
            // line_processed = true;

            dline.mode = INSERTION;
            // line_processed = true;
        } else if (line[0] == '-') {
            dline.mode = DELETION;
            // line_processed = true;
        } else if (line[0] == ' ') {
            // Context line (unchanged)
            dline.mode = EQ;
        }
        
        // if (line_processed) {
        // Add the line to the most recent file
        this->files.back().lines.push_back(dline);
        this->curr_line_num += 1;
    }
}

    }
}
DiffReader::~DiffReader() {}

=======================
=== INSERTION CHUNK ===
File: shared/diffreader.cpp
Content:
DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types) {
    DiffChunk result;
    result.filepath = file.filepath;
    
    for (const DiffLine& line : file.lines) {
        // If types is empty, return all lines
        if (types.empty()) {
            result.lines.push_back(line);
        } else {
            // Check if line's mode is in the types vector

        } else {
            // Check if line's mode is in the types vector
            for (const DiffMode& type : types) {
                if (line.mode == type) {
                    result.lines.push_back(line);
                    break;
                }
            }
        }
    }
    
    return result;
};
string combineContent(DiffChunk chunk) {
    string result = "";
    for (const DiffLine& line : chunk.lines) {
        result += line.content + "\n";
    }
    return result;
};

=======================
=== DELETION CHUNK ===
File: shared/diffreader.cpp
Content:
#include "diffreader.hpp"
#include <vector>
DiffReader::DiffReader(istream& in, bool verbose) : in(in), verbose(verbose), in_file(false), in_chunk(false) {
    this->diff_header_regex = regex("^diff --git a/(.*) b/(.*)");
    this->chunk_header_regex = regex("^@@.*@@.*");
    this->ins_regex = regex("^\\+(?!\\+)(.*)");
    this->del_regex = regex("^\\-(?!\\-)(.*)");
}

    this->del_regex = regex("^\\-(?!\\-)(.*)");
}
vector<DiffFile> DiffReader::getFiles() const {
    return this->files;
}
        // Start new file
        DiffFile current_file = DiffFile{};
        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
        this->in_file = true;
        this->in_chunk = false;
        return;
    }
    // Check for chunk header (@@)

======================
=== DELETION CHUNK ===
File: shared/diffreader.cpp
Content:
    if (this->in_file && line.substr(0, 2) == "@@") {
        this->in_chunk = true;
        if (this->verbose){
    // Process diff lines if we're in a chunk
    if (this->in_file && this->in_chunk && !this->files.empty()) {
        DiffLine dline;
        // bool line_processed = false;

        if (this->verbose){
            cout << "LINE BEING ADDED: " << line << endl;
        }
        
        if (line[0] == '+') {
            dline.mode = INSERTION;
            dline.content = line.substr(1);

            dline.mode = INSERTION;
            dline.content = line.substr(1);
            // line_processed = true;
        } else if (line[0] == '-') {
            dline.mode = DELETION;
            dline.content = line.substr(1);
            // line_processed = true;
        } else if (line[0] == ' ') {
            // Context line (unchanged)
            dline.mode = EQ;
            dline.content = line.substr(1); // Remove the leading space
            // line_processed = true;
        }
        
        // if (line_processed) {
        // Add the line to the most recent file
        this->files.back().lines.push_back(dline);
        // }
    }
}

    }
}
DiffReader::~DiffReader() {}

======================
LANGUGE: cpp
=== INSERTION CHUNK ===
File: shared/diffreader.hpp
Content:
#ifndef DIFFREADER_HPP
#define DIFFREADER_HPP

#include <iostream>
#include <string>
#include <regex>
struct DiffLine {
    DiffMode mode;
    string content;
    int line_num;
};
struct DiffFile {

};
struct DiffFile {
    string filepath;
    vector<DiffLine> lines;
};
//same data different purpose
struct DiffChunk {
    string filepath;
    vector<DiffLine> lines;
};
class DiffReader {
private:
    istream& in;
    bool verbose;

    regex diff_header_regex;

    bool in_file;
    bool in_chunk;
    int curr_line_num;

    vector<DiffFile> files;

    vector<DiffFile> getFiles() const;
    void ingestDiff();
    ~DiffReader();
};

DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types);
string combineContent(DiffChunk chunk);

#endif // DIFFREADER_HPP

=======================
=== DELETION CHUNK ===
File: shared/diffreader.hpp
Content:
#include <iostream>
#include <string>
#include <regex>
struct DiffLine {
    DiffMode mode;
    string content;
};
struct DiffFile {
    string filepath;
    vector<DiffLine> lines;
};
class DiffReader {
private:
    istream& in;
    bool verbose;

    regex diff_header_regex;
    regex chunk_header_regex;
    regex ins_regex;

    regex chunk_header_regex;
    regex ins_regex;
    regex del_regex;

    bool in_file;
    bool in_chunk;

    vector<DiffFile> files;

    vector<DiffFile> getFiles() const;
    void ingestDiff();
    ~DiffReader();
};

======================

#include "chunker.hpp"
Chunker::Chunker() {
}
Chunker::~Chunker() {
}

class Chunker {
private:
public:
    Chunker();
    
    ~Chunker();
};

private:
  vector<vector<int>> clusters;
public:
  HierachicalClustering();
  void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
  vector<vector<int>> get_clusters();
  ~HierachicalClustering();
};

#include "diffreader.hpp"
#include <regex>
#include <set>
#include <vector>

struct Chunk {
  string code;
  vector<float> embedding;
int main(int argc, char *argv[]) {
  // string api_key = getenv("OPENAI_API_KEY");
  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
  // vector<vector<float>> embeddings;
  //handles reading from cin too
  DiffReader dr(cin);
  dr.ingestDiff();
  cout << "Parsed " << dr.getFiles().size() << " files from git diff" << endl;

#ifndef AST_HPP
#define AST_HPP

#include <string>
#include <cassert>
#include <cstdio>
#include <vector>
#include <cpp-tree-sitter.h>
#include <vector>
#include "diffreader.hpp"

using namespace std;
// Function declarations
vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars = 1500);
ts::Tree codeToTree(const string& code, const string& language);
string detectLanguageFromPath(const string& filepath);
vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
bool isTextFile(const string& filepath);

#endif // AST_HPP 

  // // Process each file with language-specific parsing
  // vector<Chunk> all_chunks;

TSLanguage* tree_sitter_go();
}
// Helper function to calculate the total character size of DiffLines
size_t calculateDiffLinesSize(const vector<DiffLine>& lines) {
  size_t totalSize = 0;
  for (const DiffLine& line : lines) {
      totalSize += line.content.length() + 1;
  }
  return totalSize;
}
// Helper function to extract DiffLines that fall within a byte range
vector<DiffLine> extractLinesInRange(const vector<DiffLine>& diffLines, size_t startByte, size_t endByte) {
  vector<DiffLine> result;
  size_t currentByte = 0;
  
  for (const auto& line : diffLines) {
      size_t lineStart = currentByte;
      size_t lineEnd = currentByte + line.content.length() + 1; // +1 for newline
      
      // Check if this line overlaps with the target range
      if (lineStart < endByte && lineEnd > startByte) {
          result.push_back(line);
      }
      
      currentByte = lineEnd;
      
      // Early exit if we've passed the end of the range
      if (currentByte >= endByte) {
          break;
      }
  }
  
  return result;
}

vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {

vector<DiffChunk> chunkNode(const ts::Node& node, const DiffChunk& diffChunk, size_t maxChars) {
  vector<DiffChunk> newChunks;
  DiffChunk currentChunk;
  currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
  size_t currentChunkSize = 0;

  for (size_t i = 0; i < node.getNumChildren(); i++) {
      ts::Node child = node.getChild(i);
      auto byteRange = child.getByteRange();
      
      vector<DiffLine> childLines = extractLinesInRange(diffChunk.lines, byteRange.start, byteRange.end);
      size_t childSize = calculateDiffLinesSize(childLines);

      if (childSize > maxChars) {
          if (!currentChunk.lines.empty()) {
              newChunks.push_back(currentChunk);
              currentChunk = DiffChunk();
              currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
              currentChunkSize = 0;
          }
          auto childChunks = chunkNode(child, diffChunk, maxChars);
          newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
      }
      else if (currentChunkSize + childSize > maxChars) {
          newChunks.push_back(currentChunk);
          currentChunk = DiffChunk();
          currentChunk.filepath = diffChunk.filepath; // Preserve the filepath
          currentChunk.lines = childLines;
          currentChunkSize = childSize;
      }
      else {
          currentChunk.lines.insert(currentChunk.lines.end(), childLines.begin(), childLines.end());
          currentChunkSize += childSize;
      }
  }
  if (!currentChunk.lines.empty()) {
      newChunks.push_back(currentChunk);
  }
  return newChunks;
}

ts::Tree codeToTree(const string& code, const string& language) {
    return "typescript";
  } else if (extension == ".go") {
    return "go";
  } else if (extension == ".cpp") {
    return "cpp"; // Default fallback
  } else {
    return "text";
  }
}

    if (this->in_file && line.substr(0, 2) == "@@") {
        this->in_chunk = true;
        if (this->verbose){
    // Process diff lines if we're in a chunk
    if (this->in_file && this->in_chunk && !this->files.empty()) {
        DiffLine dline;
        dline.content = line.substr(1);
        dline.line_num = this->curr_line_num;


        if (this->verbose){
            cout << "LINE BEING ADDED: " << line << endl;
        }
        
        
        
        if (line[0] == '+') {
            dline.mode = INSERTION;
            // line_processed = true;
        } else if (line[0] == '-') {
            dline.mode = DELETION;
            // line_processed = true;
        } else if (line[0] == ' ') {
            // Context line (unchanged)
            dline.mode = EQ;
        }
        
        // if (line_processed) {
        // Add the line to the most recent file
        this->files.back().lines.push_back(dline);
        this->curr_line_num += 1;
    }
}

    }
}
DiffReader::~DiffReader() {}

    if (this->in_file && line.substr(0, 2) == "@@") {
        this->in_chunk = true;
        if (this->verbose){
    // Process diff lines if we're in a chunk
    if (this->in_file && this->in_chunk && !this->files.empty()) {
        DiffLine dline;
        // bool line_processed = false;

        if (this->verbose){
            cout << "LINE BEING ADDED: " << line << endl;
        }
        
        if (line[0] == '+') {
            dline.mode = INSERTION;
            dline.content = line.substr(1);
            // line_processed = true;
        } else if (line[0] == '-') {
            dline.mode = DELETION;
            dline.content = line.substr(1);
            // line_processed = true;
        } else if (line[0] == ' ') {
            // Context line (unchanged)
            dline.mode = EQ;
            dline.content = line.substr(1); // Remove the leading space
            // line_processed = true;
        }
        
        // if (line_processed) {
        // Add the line to the most recent file
        this->files.back().lines.push_back(dline);
        // }
    }
}

    }
}
DiffReader::~DiffReader() {}

DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types) {
    DiffChunk result;
    result.filepath = file.filepath;
    
    for (const DiffLine& line : file.lines) {
        // If types is empty, return all lines
        if (types.empty()) {
            result.lines.push_back(line);
        } else {
            // Check if line's mode is in the types vector
            for (const DiffMode& type : types) {
                if (line.mode == type) {
                    result.lines.push_back(line);
                    break;
                }
            }
        }
    }
    
    return result;
};
string combineContent(DiffChunk chunk) {
    string result = "";
    for (const DiffLine& line : chunk.lines) {
        result += line.content + "\n";
    }
    return result;
};

#ifndef DIFFREADER_HPP
#define DIFFREADER_HPP

#include <iostream>
#include <string>
#include <regex>
struct DiffLine {
    DiffMode mode;
    string content;
    int line_num;
};
struct DiffFile {
    string filepath;
    vector<DiffLine> lines;
};
//same data different purpose
struct DiffChunk {
    string filepath;
    vector<DiffLine> lines;
};
class DiffReader {
private:
    istream& in;
    bool verbose;

    regex diff_header_regex;

    bool in_file;
    bool in_chunk;
    int curr_line_num;

    vector<DiffFile> files;

    vector<DiffFile> getFiles() const;
    void ingestDiff();
    ~DiffReader();
};

DiffChunk getDiffContent(DiffFile file, vector<DiffMode> types);
string combineContent(DiffChunk chunk);

#endif // DIFFREADER_HPP

private:
  vector<vector<int>> clusters;
public:
    HierachicalClustering();
    void cluster(vector<vector<float>> data, float distance_threshold = 0.5);
    vector<vector<int>> get_clusters();
    ~HierachicalClustering();
};

#include "diffreader.hpp"
#include <regex>
#include <set>
struct Chunk {
  string code;
  vector<float> embedding;


int main(int argc, char *argv[]) {
  string line;
  string git_diff;


  // string api_key = getenv("OPENAI_API_KEY");
  
  // OpenAI_EmbeddingsAPI openai_embeddings_api(api_key);
  // vector<vector<float>> embeddings;

  DiffReader dr(cin);

  dr.ingestDiff();


  cout << dr.getFiles().size() << endl;

  for (const auto& file : dr.getFiles()) {
    cout << "File: " << file.filepath << endl;
    for (const auto& line : file.lines) {
      string mode_str;
      switch (line.mode) {
        case EQ: mode_str = "EQ"; break;
        case INSERTION: mode_str = "INSERTION"; break;
        case DELETION: mode_str = "DELETION"; break;
      }
      cout << "  [" << mode_str << "] " << line.content << endl;
    }
    cout << endl;
  }
  // // Parse git diff to extract file-specific changes
  // vector<DiffFile> diff_files;
  // DiffFile current_file;
  // bool in_file = false;
  // bool in_chunk = false;
  // regex diff_header_regex("^diff --git a/(.*) b/(.*)");
  // regex chunk_header_regex("^@@.*@@");
  // regex ins_regex("^\\+(?!\\+)(.*)");
  // regex del_regex("^\\-(?!\\-)(.*)");
  // while (getline(cin, line)) {
  //   smatch match;
  //   // Check for new file header
  //   if (regex_match(line, match, diff_header_regex)) {
  //     // Save previous file if exists
  //     if (in_file) {
  //       diff_files.push_back(current_file);
  //     }

  //     // Start new file
  //     current_file = DiffFile();
  //     current_file.filepath = match[2]; // Use 'b/' path (after changes)
  //     current_file.language = detectLanguageFromPath(current_file.filepath);
  //     in_file = true;
  //     in_chunk = false;
  //     continue;
  //   }
  //   // Check for chunk header (@@)
  //   if (in_file && regex_match(line, chunk_header_regex)) {
  //     in_chunk = true;
  //     continue;
  //   }
  //   // Process diff lines if we're in a chunk
  //   if (in_file && in_chunk) {
  //     if (regex_match(line, match, ins_regex)) {
  //       current_file.insertions += match[1].str() + "\n";
  //     } else if (regex_match(line, match, del_regex)) {
  //       current_file.deletions += match[1].str() + "\n";
  //     }
  //   }
  // }
  // // Don't forget the last file
  // if (in_file) {
  //   diff_files.push_back(current_file);
  // }
  // cerr << "Parsed " << diff_files.size() << " files from git diff" << endl;
  // // Process each file with language-specific parsing
  // vector<Chunk> all_chunks;

TSLanguage* tree_sitter_go();
}
vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars) {
    vector<string> newChunks;
    string currentChunk;

    for (size_t i = 0; i < node.getNumChildren(); i++) {
        ts::Node child = node.getChild(i);
        auto byteRange = child.getByteRange();
        size_t childLength = byteRange.end - byteRange.start;

        if (childLength > maxChars) {
            if (!currentChunk.empty()) {
                newChunks.push_back(currentChunk);
                currentChunk.clear();
            }
            auto childChunks = chunkNode(child, text, maxChars);
            newChunks.insert(newChunks.end(), childChunks.begin(), childChunks.end());
        }
        else if (currentChunk.length() + childLength > maxChars) {
            newChunks.push_back(currentChunk);
            currentChunk = text.substr(byteRange.start, childLength);
        }
        else {
            currentChunk += text.substr(byteRange.start, childLength);
        }
    }

    if (!currentChunk.empty()) {
        newChunks.push_back(currentChunk);
    }

    return newChunks;
}
ts::Tree codeToTree(const string& code, const string& language) {
    return "typescript";
  } else if (extension == ".go") {
    return "go";
  } else {
    return "cpp"; // Default fallback
  }
}
// int main() {
//   string git_diff;
//   string line;
//   while (getline(cin, line))
//   {
//       git_diff += line + "\n";
//   }
//   size_t pos = 0;

//   while ((pos = git_diff.find("-", pos)) != string::npos) {
//       git_diff.replace(pos, 1, "");
//   }
//   string original_diff = git_diff;
//   regex re("(@@).+(@@)");
//   sregex_iterator regex_delim = sregex_iterator(git_diff.begin(), git_diff.end(), re);
//   sregex_iterator end = sregex_iterator();
//   vector<string> git_chunks;
//   for (sregex_iterator it = regex_delim; it != end; it++) {
//       smatch match = *it;
//       git_chunks.push_back(match.suffix());
//   }
//   ts::Tree tree = codeToTree(original_diff);
//   vector<string> chunks = chunkNode(tree.getRootNode(), original_diff);
//   for (int i = 0; i < chunks.size(); i++) {
//     cout << "Chunk " << i << ": " << chunks[i] << endl;
//   }
//   return 0;
// }

#include <string>
#include <cassert>
#include <cstdio>
#include <vector>
#include <cpp-tree-sitter.h>
#include <vector>
using namespace std;
// Function declarations
vector<string> chunkNode(const ts::Node& node, const string& text, size_t maxChars = 1500);
ts::Tree codeToTree(const string& code, const string& language);
string detectLanguageFromPath(const string& filepath);
vector<string> chunkByCharacters(const string& text, size_t maxChars = 1000, size_t overlap = 100);
bool isTextFile(const string& filepath); 

#include "diffreader.hpp"
#include <vector>
DiffReader::DiffReader(istream& in, bool verbose) : in(in), verbose(verbose), in_file(false), in_chunk(false) {
    this->diff_header_regex = regex("^diff --git a/(.*) b/(.*)");
    this->chunk_header_regex = regex("^@@.*@@.*");
    this->ins_regex = regex("^\\+(?!\\+)(.*)");
    this->del_regex = regex("^\\-(?!\\-)(.*)");
}
vector<DiffFile> DiffReader::getFiles() const {
    return this->files;
}
        // Start new file
        DiffFile current_file = DiffFile{};
        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
        this->in_file = true;
        this->in_chunk = false;
        return;
    }
    // Check for chunk header (@@)

#include "diffreader.hpp"
#include <vector>
DiffReader::DiffReader(istream& in, bool verbose) 
    : in(in), 
      verbose(verbose), 
      diff_header_regex(regex("^diff --git a/(.*) b/(.*)")),
      in_file(false), 
      in_chunk(false), 
      curr_line_num(0)
{}
vector<DiffFile> DiffReader::getFiles() const {
    return this->files;
}
        // Start new file
        DiffFile current_file = DiffFile{};
        current_file.filepath = match[2].str(); // Use 'b/' path (after changes)
        this->curr_line_num = 0;
        this->in_file = true;
        this->in_chunk = false;
        return;
    }
    // Check for chunk header (@@). This will skip some context for the diff (one line per chunk header). TODO: fix

#include <iostream>
#include <string>
#include <regex>
struct DiffLine {
    DiffMode mode;
    string content;
};
struct DiffFile {
    string filepath;
    vector<DiffLine> lines;
};
class DiffReader {
private:
    istream& in;
    bool verbose;

    regex diff_header_regex;
    regex chunk_header_regex;
    regex ins_regex;
    regex del_regex;

    bool in_file;
    bool in_chunk;

    vector<DiffFile> files;

    vector<DiffFile> getFiles() const;
    void ingestDiff();
    ~DiffReader();
};


